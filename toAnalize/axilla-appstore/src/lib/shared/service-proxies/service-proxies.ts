//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';

import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';

import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as dayjs from 'dayjs';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ApiConfServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves all API calls.
     * @return Success
     */
    getApiCalls(): Observable<IApiCallsOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/GetApiCalls";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiCalls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiCalls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApiCallsOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApiCallsOutputDto[]>;
        }));
    }

    protected processGetApiCalls(response: HttpResponseBase): Observable<IApiCallsOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApiCallsOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IApiCallsOutputDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieves API calls by application ID.
     * @param id (optional)
     * @return Success
     */
    getByAppId(id: string | undefined): Observable<IApiCallsOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/GetByAppId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByAppId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByAppId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApiCallsOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApiCallsOutputDto[]>;
        }));
    }

    protected processGetByAppId(response: HttpResponseBase): Observable<IApiCallsOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApiCallsOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IApiCallsOutputDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieves an API call by ID.
     * @param id (optional)
     * @return Success
     */
    getById(id: string | undefined): Observable<IApiCallsOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApiCallsOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApiCallsOutputDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<IApiCallsOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCallsOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IApiCallsOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a JSON string for a given GUID.
     * @param guid (optional) The GUID.
     * @return Success
     */
    getJSON(guid: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/GetJSON?";
        if (guid === null)
            throw new Error("The parameter 'guid' cannot be null.");
        else if (guid !== undefined)
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJSON(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJSON(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetJSON(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as string);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a JSON index schema for a given GUID.
     * @param guid (optional) The GUID.
     * @return Success
     */
    getJSONIndexSchema(guid: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/GetJSONIndexSchema?";
        if (guid === null)
            throw new Error("The parameter 'guid' cannot be null.");
        else if (guid !== undefined)
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJSONIndexSchema(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJSONIndexSchema(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetJSONIndexSchema(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as string);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Saves the schema for an API call.
     * @param body (optional) The schema input.
     * @return Success
     */
    saveSchema(body: ISaveSchemaInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/SaveSchema";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSchema(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSchema(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSaveSchema(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as string);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Translates the API call.
     * @return Success
     */
    translate(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/Translate";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTranslate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTranslate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processTranslate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as string);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an API call.
     * @param body (optional) The API call input.
     * @return Success
     */
    update(body: IApiCallInputDto | undefined): Observable<IApiCallsOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApiCallsOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApiCallsOutputDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IApiCallsOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCallsOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IApiCallsOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes an API call by ID.
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes an API call header by ID.
     * @param id (optional)
     * @return Success
     */
    deleteHeader(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/DeleteHeader?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteHeader(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Receive data from a specific channel. The output can be formated using the output formating option
     * @param body (optional) The input parameters for the API call.
     * @return Success
     */
    executeCall(body: IExecuteApiCallInputDto | undefined): Observable<IExecuteApiCallOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ApiConf/ExecuteCall";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteCall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteCall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IExecuteApiCallOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IExecuteApiCallOutputDto>;
        }));
    }

    protected processExecuteCall(response: HttpResponseBase): Observable<IExecuteApiCallOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecuteApiCallOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IExecuteApiCallOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ApiConnectionSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: ICreateApiConnectionSettingDto | undefined): Observable<IApiConnectionSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApiConnectionSetting/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApiConnectionSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApiConnectionSettingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IApiConnectionSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiConnectionSettingDto.fromJS(resultData200);
            return _observableOf(resultData200 as IApiConnectionSettingDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<IApiConnectionSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApiConnectionSetting/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApiConnectionSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApiConnectionSettingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IApiConnectionSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiConnectionSettingDto.fromJS(resultData200);
            return _observableOf(resultData200 as IApiConnectionSettingDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) Gets or sets the filter for the API connection settings.
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfApiConnectionSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApiConnectionSetting/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfApiConnectionSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfApiConnectionSettingDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IPagedResultDtoOfApiConnectionSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApiConnectionSettingDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfApiConnectionSettingDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: IUpdateApiConnectionSettingDto | undefined): Observable<IApiConnectionSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/ApiConnectionSetting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApiConnectionSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApiConnectionSettingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IApiConnectionSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiConnectionSettingDto.fromJS(resultData200);
            return _observableOf(resultData200 as IApiConnectionSettingDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApiConnectionSetting/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppJobSchedulerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param jobDefinitionId (optional)
     * @return Success
     */
    stop(jobDefinitionId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppJobScheduler/Stop?";
        if (jobDefinitionId === null)
            throw new Error("The parameter 'jobDefinitionId' cannot be null.");
        else if (jobDefinitionId !== undefined)
            url_ += "jobDefinitionId=" + encodeURIComponent("" + jobDefinitionId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStop(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllList(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfJobDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppJobScheduler/GetAllList?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfJobDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfJobDefinitionDto>;
        }));
    }

    protected processGetAllList(response: HttpResponseBase): Observable<IPagedResultDtoOfJobDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfJobDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all registered work flow processor types
     * @return Success
     */
    getWorkflowProcessorNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/AppJobScheduler/GetWorkflowProcessorNames";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkflowProcessorNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkflowProcessorNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetWorkflowProcessorNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as string[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Schedule Job
     * @param body (optional)
     * @return Success
     */
    create(body: ICreateJobDefinitionInput | undefined): Observable<IJobDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppJobScheduler/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobDefinitionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IJobDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IJobDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<IJobDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppJobScheduler/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobDefinitionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IJobDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IJobDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfJobDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppJobScheduler/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfJobDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfJobDefinitionDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IPagedResultDtoOfJobDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfJobDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: IUpdateJobDefinitionInput | undefined): Observable<IJobDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppJobScheduler/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobDefinitionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IJobDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IJobDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppJobScheduler/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppLoggerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Gets the logs.
     * @param loggerName (optional) Name of the logger.
     * @return Success
     */
    getLogs(loggerName: string | undefined): Observable<IRegistrationInputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppLogger/GetLogs?";
        if (loggerName === null)
            throw new Error("The parameter 'loggerName' cannot be null.");
        else if (loggerName !== undefined)
            url_ += "loggerName=" + encodeURIComponent("" + loggerName) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IRegistrationInputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IRegistrationInputDto[]>;
        }));
    }

    protected processGetLogs(response: HttpResponseBase): Observable<IRegistrationInputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegistrationInputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IRegistrationInputDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the paged result logs.
     * @param loggerName (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getPagedResultLogs(loggerName: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfRegistrationInputDto> {
        let url_ = this.baseUrl + "/api/services/app/AppLogger/GetPagedResultLogs?";
        if (loggerName === null)
            throw new Error("The parameter 'loggerName' cannot be null.");
        else if (loggerName !== undefined)
            url_ += "LoggerName=" + encodeURIComponent("" + loggerName) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedResultLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedResultLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfRegistrationInputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfRegistrationInputDto>;
        }));
    }

    protected processGetPagedResultLogs(response: HttpResponseBase): Observable<IPagedResultDtoOfRegistrationInputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRegistrationInputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfRegistrationInputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppServiceBaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Change a setting. Currently changing authorization parameters is not allowed.
     * @param body (optional)
     * @return Success
     */
    changeAppSettings(body: IChangeAppSettingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/ChangeAppSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeAppSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeAppSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeAppSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all app settings
     * @param appId (optional)
     * @param channelId (optional)
     * @return Success
     */
    getAllSettings(appId: string | undefined, channelId: string | undefined): Observable<IAppCustomSettingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/GetAllSettings?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "AppId=" + encodeURIComponent("" + appId) + "&";
        if (channelId === null)
            throw new Error("The parameter 'channelId' cannot be null.");
        else if (channelId !== undefined)
            url_ += "ChannelId=" + encodeURIComponent("" + channelId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IAppCustomSettingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IAppCustomSettingDto[]>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<IAppCustomSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppCustomSettingDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IAppCustomSettingDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a new channel
     * @param body (optional)
     * @return Success
     */
    createChannel(body: ICreateNewChannelInput | undefined): Observable<IChannelDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/CreateChannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateChannel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateChannel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IChannelDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IChannelDefinitionDto>;
        }));
    }

    protected processCreateChannel(response: HttpResponseBase): Observable<IChannelDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IChannelDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param strFullyQualifiedName (optional)
     * @return Success
     */
    getInstance(strFullyQualifiedName: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/GetInstance?";
        if (strFullyQualifiedName === null)
            throw new Error("The parameter 'strFullyQualifiedName' cannot be null.");
        else if (strFullyQualifiedName !== undefined)
            url_ += "strFullyQualifiedName=" + encodeURIComponent("" + strFullyQualifiedName) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetInstance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the oauth information
     * @param installationId (optional)
     * @param oauthArguments (optional)
     * @return Success
     */
    getOauth2Authentication(installationId: string | undefined, oauthArguments: IAuthArguments[] | undefined): Observable<ILoginOauth2> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/GetOauth2Authentication?";
        if (installationId === null)
            throw new Error("The parameter 'installationId' cannot be null.");
        else if (installationId !== undefined)
            url_ += "installationId=" + encodeURIComponent("" + installationId) + "&";
        if (oauthArguments === null)
            throw new Error("The parameter 'oauthArguments' cannot be null.");
        else if (oauthArguments !== undefined)
            oauthArguments && oauthArguments.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "oauthArguments[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOauth2Authentication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOauth2Authentication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILoginOauth2>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILoginOauth2>;
        }));
    }

    protected processGetOauth2Authentication(response: HttpResponseBase): Observable<ILoginOauth2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginOauth2.fromJS(resultData200);
            return _observableOf(resultData200 as ILoginOauth2);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adding the auth parameters to the database
     * @param appAssignmentId (optional)
     * @param channelId (optional)
     * @param useCache (optional)
     * @param body (optional)
     * @return Success
     */
    updateAuthArguments(appAssignmentId: string | undefined, channelId: string | undefined, useCache: boolean | undefined, body: IAuthArguments[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/UpdateAuthArguments?";
        if (appAssignmentId === null)
            throw new Error("The parameter 'appAssignmentId' cannot be null.");
        else if (appAssignmentId !== undefined)
            url_ += "appAssignmentId=" + encodeURIComponent("" + appAssignmentId) + "&";
        if (channelId === null)
            throw new Error("The parameter 'channelId' cannot be null.");
        else if (channelId !== undefined)
            url_ += "channelId=" + encodeURIComponent("" + channelId) + "&";
        if (useCache === null)
            throw new Error("The parameter 'useCache' cannot be null.");
        else if (useCache !== undefined)
            url_ += "useCache=" + encodeURIComponent("" + useCache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAuthArguments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAuthArguments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAuthArguments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the authentication for an app
     * @param id (optional)
     * @return Success
     */
    getAuthentication(id: string | undefined): Observable<ILoginData> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/GetAuthentication?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthentication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthentication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILoginData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILoginData>;
        }));
    }

    protected processGetAuthentication(response: HttpResponseBase): Observable<ILoginData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginData.fromJS(resultData200);
            return _observableOf(resultData200 as ILoginData);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    startJob(body: IStartProcessorJobInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/StartJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStartJob(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    runJob(body: IApplicationJobArgsInput | undefined): Observable<IJobResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/RunJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRunJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobResultOutput>;
        }));
    }

    protected processRunJob(response: HttpResponseBase): Observable<IJobResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobResultOutput.fromJS(resultData200);
            return _observableOf(resultData200 as IJobResultOutput);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    startJobWithResult(body: IApplicationJobArgsInput | undefined): Observable<IJobResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/StartJobWithResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartJobWithResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartJobWithResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobResultOutput>;
        }));
    }

    protected processStartJobWithResult(response: HttpResponseBase): Observable<IJobResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobResultOutput.fromJS(resultData200);
            return _observableOf(resultData200 as IJobResultOutput);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * This will runs the
     * @param body (optional)
     * @return Success
     */
    startJobNow(body: IApplicationJobArgsInput | undefined): Observable<IJobResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/StartJobNow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartJobNow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartJobNow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobResultOutput>;
        }));
    }

    protected processStartJobNow(response: HttpResponseBase): Observable<IJobResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobResultOutput.fromJS(resultData200);
            return _observableOf(resultData200 as IJobResultOutput);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    startMultipleJobs(body: IStartProcessorJobInput[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/StartMultipleJobs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartMultipleJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartMultipleJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStartMultipleJobs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Start job and return result of selected step
     * @param body (optional)
     * @return Success
     */
    startJobWithStepResult(body: IJobArgsForStepResultDto | undefined): Observable<IJobResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/StartJobWithStepResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartJobWithStepResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartJobWithStepResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobResultOutput>;
        }));
    }

    protected processStartJobWithStepResult(response: HttpResponseBase): Observable<IJobResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobResultOutput.fromJS(resultData200);
            return _observableOf(resultData200 as IJobResultOutput);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Start job with modified step and get its result
     * @param body (optional)
     * @return Success
     */
    startJobWithModifiedStepResult(body: IJobArgsForModifyStepDto | undefined): Observable<IJobResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppServiceBase/StartJobWithModifiedStepResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartJobWithModifiedStepResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartJobWithModifiedStepResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobResultOutput>;
        }));
    }

    protected processStartJobWithModifiedStepResult(response: HttpResponseBase): Observable<IJobResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobResultOutput.fromJS(resultData200);
            return _observableOf(resultData200 as IJobResultOutput);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AppStoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: ICreateAppInput | undefined): Observable<IAppListDto> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IAppListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IAppListDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IAppListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppListDto.fromJS(resultData200);
            return _observableOf(resultData200 as IAppListDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Edit app definition
     * @param body (optional)
     * @return Success
     */
    edit(body: ICreateOrEditAppInput | undefined): Observable<IAppListDto> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/Edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IAppListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IAppListDto>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<IAppListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppListDto.fromJS(resultData200);
            return _observableOf(resultData200 as IAppListDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Remove ApplicationProperty by ID
     * @param appId (optional)
     * @param propertyId (optional)
     * @return Success
     */
    removeApplicationProperty(appId: string | undefined, propertyId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/RemoveApplicationProperty?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveApplicationProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveApplicationProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveApplicationProperty(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param onlyNotInstalledApps (optional)
     * @return Success
     */
    getList(onlyNotInstalledApps: boolean | undefined): Observable<IListResultDtoOfAppListDto> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/GetList?";
        if (onlyNotInstalledApps === null)
            throw new Error("The parameter 'onlyNotInstalledApps' cannot be null.");
        else if (onlyNotInstalledApps !== undefined)
            url_ += "onlyNotInstalledApps=" + encodeURIComponent("" + onlyNotInstalledApps) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IListResultDtoOfAppListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IListResultDtoOfAppListDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<IListResultDtoOfAppListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfAppListDto.fromJS(resultData200);
            return _observableOf(resultData200 as IListResultDtoOfAppListDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<IAppDefinitionOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IAppDefinitionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IAppDefinitionOutputDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IAppDefinitionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppDefinitionOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IAppDefinitionOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param onlyNotInstalledApps (optional)
     * @return Success
     */
    getAppAssignedList(onlyNotInstalledApps: boolean | undefined): Observable<IListResultDtoOfAppAssignmentListDto> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/GetAppAssignedList?";
        if (onlyNotInstalledApps === null)
            throw new Error("The parameter 'onlyNotInstalledApps' cannot be null.");
        else if (onlyNotInstalledApps !== undefined)
            url_ += "onlyNotInstalledApps=" + encodeURIComponent("" + onlyNotInstalledApps) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppAssignedList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppAssignedList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IListResultDtoOfAppAssignmentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IListResultDtoOfAppAssignmentListDto>;
        }));
    }

    protected processGetAppAssignedList(response: HttpResponseBase): Observable<IListResultDtoOfAppAssignmentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfAppAssignmentListDto.fromJS(resultData200);
            return _observableOf(resultData200 as IListResultDtoOfAppAssignmentListDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getById(id: string | undefined): Observable<IAppAssignmentListDto> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IAppAssignmentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IAppAssignmentListDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<IAppAssignmentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppAssignmentListDto.fromJS(resultData200);
            return _observableOf(resultData200 as IAppAssignmentListDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getByName(id: string | undefined): Observable<IAppAssignmentListDto> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/GetByName?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IAppAssignmentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IAppAssignmentListDto>;
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<IAppAssignmentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppAssignmentListDto.fromJS(resultData200);
            return _observableOf(resultData200 as IAppAssignmentListDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getStatus(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/GetStatus";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addToTenant(body: IEntityDtoOfGuid | undefined): Observable<IAppAssignmentOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/AddToTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IAppAssignmentOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IAppAssignmentOutput>;
        }));
    }

    protected processAddToTenant(response: HttpResponseBase): Observable<IAppAssignmentOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppAssignmentOutput.fromJS(resultData200);
            return _observableOf(resultData200 as IAppAssignmentOutput);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    removeFromTenant(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/RemoveFromTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveFromTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appTenantAssignmentId (optional)
     * @return Success
     */
    removeAndSave(appTenantAssignmentId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/RemoveAndSave?";
        if (appTenantAssignmentId === null)
            throw new Error("The parameter 'appTenantAssignmentId' cannot be null.");
        else if (appTenantAssignmentId !== undefined)
            url_ += "appTenantAssignmentId=" + encodeURIComponent("" + appTenantAssignmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAndSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAndSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveAndSave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addApiCall(body: ICreateApiInputDto | undefined): Observable<IApiCallsOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/AddApiCall";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddApiCall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddApiCall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApiCallsOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApiCallsOutputDto>;
        }));
    }

    protected processAddApiCall(response: HttpResponseBase): Observable<IApiCallsOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiCallsOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IApiCallsOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAppDefinitionIdByInstallation(id: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AppStore/GetAppDefinitionIdByInstallation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppDefinitionIdByInstallation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppDefinitionIdByInstallation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAppDefinitionIdByInstallation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as string);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChannelDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all channel definitions based on the installed app id.
     * @param installedAppid (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllForApp(installedAppid: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfChannelDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/ChannelDefinition/GetAllForApp?";
        if (installedAppid === null)
            throw new Error("The parameter 'installedAppid' cannot be null.");
        else if (installedAppid !== undefined)
            url_ += "InstalledAppid=" + encodeURIComponent("" + installedAppid) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfChannelDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfChannelDefinitionDto>;
        }));
    }

    protected processGetAllForApp(response: HttpResponseBase): Observable<IPagedResultDtoOfChannelDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfChannelDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfChannelDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete all channels with all settings related to the channel and scheduled jobs included
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChannelDefinition/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param channelId (optional)
     * @return Success
     */
    renewToken(channelId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChannelDefinition/RenewToken?";
        if (channelId === null)
            throw new Error("The parameter 'channelId' cannot be null.");
        else if (channelId !== undefined)
            url_ += "channelId=" + encodeURIComponent("" + channelId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenewToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenewToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenewToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<IChannelDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/ChannelDefinition/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IChannelDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IChannelDefinitionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IChannelDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IChannelDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfChannelDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/ChannelDefinition/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfChannelDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfChannelDefinitionDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IPagedResultDtoOfChannelDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfChannelDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfChannelDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: ICreateChannelDefinitionDto | undefined): Observable<IChannelDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/ChannelDefinition/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IChannelDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IChannelDefinitionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IChannelDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IChannelDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: IUpdateChannelDefinitionDto | undefined): Observable<IChannelDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/ChannelDefinition/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IChannelDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IChannelDefinitionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IChannelDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IChannelDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EnterpriseSearchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteDataFromES(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/DeleteDataFromES?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDataFromES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDataFromES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDataFromES(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    protectData(body: IProtectDataFromESInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/ProtectData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProtectData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProtectData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processProtectData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    cleanHistory(body: ICleanHistoryInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/CleanHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCleanHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param mainContextHashKey (optional)
     * @return Success
     */
    removeDataByHash(mainContextHashKey: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/RemoveDataByHash?";
        if (mainContextHashKey === null)
            throw new Error("The parameter 'mainContextHashKey' cannot be null.");
        else if (mainContextHashKey !== undefined)
            url_ += "MainContextHashKey=" + encodeURIComponent("" + mainContextHashKey) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDataByHash(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDataByHash(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDataByHash(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAvailableFilters(): Observable<IFilterOptionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/GetAvailableFilters";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableFilters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableFilters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IFilterOptionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IFilterOptionDto[]>;
        }));
    }

    protected processGetAvailableFilters(response: HttpResponseBase): Observable<IFilterOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FilterOptionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IFilterOptionDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @param parentOnly (optional)
     * @return Success
     */
    getItemPreview(id: string | undefined, parentOnly: boolean | undefined): Observable<IPreviewItemOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/GetItemPreview?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (parentOnly === null)
            throw new Error("The parameter 'parentOnly' cannot be null.");
        else if (parentOnly !== undefined)
            url_ += "ParentOnly=" + encodeURIComponent("" + parentOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPreviewItemOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPreviewItemOutputDto>;
        }));
    }

    protected processGetItemPreview(response: HttpResponseBase): Observable<IPreviewItemOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreviewItemOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPreviewItemOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getItemDocumentsPreview(id: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfPreviewDocumentOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/GetItemDocumentsPreview?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemDocumentsPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemDocumentsPreview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfPreviewDocumentOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfPreviewDocumentOutputDto>;
        }));
    }

    protected processGetItemDocumentsPreview(response: HttpResponseBase): Observable<IPagedResultDtoOfPreviewDocumentOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPreviewDocumentOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfPreviewDocumentOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param currentItemId (optional)
     * @param type (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getRelatedDocuments(currentItemId: string | undefined, type: RelatedDocumentTypes | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ISearchResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/GetRelatedDocuments?";
        if (currentItemId === null)
            throw new Error("The parameter 'currentItemId' cannot be null.");
        else if (currentItemId !== undefined)
            url_ += "CurrentItemId=" + encodeURIComponent("" + currentItemId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ISearchResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ISearchResultDto>;
        }));
    }

    protected processGetRelatedDocuments(response: HttpResponseBase): Observable<ISearchResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultDto.fromJS(resultData200);
            return _observableOf(resultData200 as ISearchResultDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param documentType (optional)
     * @param sessionName (optional)
     * @param agentName (optional)
     * @return Success
     */
    getLastUserDocument(documentType: string | undefined, sessionName: string | undefined, agentName: string | undefined): Observable<IGetLastUserDocumentOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/GetLastUserDocument?";
        if (documentType === null)
            throw new Error("The parameter 'documentType' cannot be null.");
        else if (documentType !== undefined)
            url_ += "DocumentType=" + encodeURIComponent("" + documentType) + "&";
        if (sessionName === null)
            throw new Error("The parameter 'sessionName' cannot be null.");
        else if (sessionName !== undefined)
            url_ += "SessionName=" + encodeURIComponent("" + sessionName) + "&";
        if (agentName === null)
            throw new Error("The parameter 'agentName' cannot be null.");
        else if (agentName !== undefined)
            url_ += "AgentName=" + encodeURIComponent("" + agentName) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastUserDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastUserDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetLastUserDocumentOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetLastUserDocumentOutputDto>;
        }));
    }

    protected processGetLastUserDocument(response: HttpResponseBase): Observable<IGetLastUserDocumentOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLastUserDocumentOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IGetLastUserDocumentOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    searchData(body: IEnterpriseSearchItemsInputDto | undefined): Observable<ISearchResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/SearchData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ISearchResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ISearchResultDto>;
        }));
    }

    protected processSearchData(response: HttpResponseBase): Observable<ISearchResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultDto.fromJS(resultData200);
            return _observableOf(resultData200 as ISearchResultDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    registerAIResultToES(body: IRegisterAIDocumentInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/RegisterAIResultToES";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterAIResultToES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterAIResultToES(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRegisterAIResultToES(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as string);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addDataToEnterpriseSearch(body: IAddDataToEnterpriseSearchInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/AddDataToEnterpriseSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDataToEnterpriseSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDataToEnterpriseSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddDataToEnterpriseSearch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    tokenizeContent(body: ITokenizeTextContentInputDto | undefined): Observable<ITokenizeTextContentOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/TokenizeContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTokenizeContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTokenizeContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ITokenizeTextContentOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ITokenizeTextContentOutputDto>;
        }));
    }

    protected processTokenizeContent(response: HttpResponseBase): Observable<ITokenizeTextContentOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenizeTextContentOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as ITokenizeTextContentOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    checkIfExist(body: ICheckIfExistInputDto | undefined): Observable<ICheckIfExistOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/CheckIfExist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ICheckIfExistOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ICheckIfExistOutputDto>;
        }));
    }

    protected processCheckIfExist(response: HttpResponseBase): Observable<ICheckIfExistOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckIfExistOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as ICheckIfExistOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    write(body: IWriteDataInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/Write";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWrite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWrite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWrite(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    search(body: ISearchItemsInputDto | undefined): Observable<IPagedResultDtoOfEnterpriseSearchResultOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearch/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfEnterpriseSearchResultOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfEnterpriseSearchResultOutputDto>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<IPagedResultDtoOfEnterpriseSearchResultOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEnterpriseSearchResultOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfEnterpriseSearchResultOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EnterpriseSearchBase64ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    registerThumbnails(body: IRegisterThumbnailsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchBase64/RegisterThumbnails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterThumbnails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterThumbnails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegisterThumbnails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    registerListThumbnails(body: IRegisterListThumbnailsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchBase64/RegisterListThumbnails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterListThumbnails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterListThumbnails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegisterListThumbnails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param documentRootId (optional)
     * @param thumbnailsType (optional)
     * @param originalContent (optional)
     * @param configuration_Width (optional)
     * @param configuration_Height (optional)
     * @param configuration_MaxWidth (optional)
     * @return Success
     */
    getThumbnailsForContent(documentRootId: string | undefined, thumbnailsType: string | undefined, originalContent: string | undefined, configuration_Width: number | undefined, configuration_Height: number | undefined, configuration_MaxWidth: number | undefined): Observable<ICalculateThumbnailsOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchBase64/GetThumbnailsForContent?";
        if (documentRootId === null)
            throw new Error("The parameter 'documentRootId' cannot be null.");
        else if (documentRootId !== undefined)
            url_ += "DocumentRootId=" + encodeURIComponent("" + documentRootId) + "&";
        if (thumbnailsType === null)
            throw new Error("The parameter 'thumbnailsType' cannot be null.");
        else if (thumbnailsType !== undefined)
            url_ += "ThumbnailsType=" + encodeURIComponent("" + thumbnailsType) + "&";
        if (originalContent === null)
            throw new Error("The parameter 'originalContent' cannot be null.");
        else if (originalContent !== undefined)
            url_ += "OriginalContent=" + encodeURIComponent("" + originalContent) + "&";
        if (configuration_Width === null)
            throw new Error("The parameter 'configuration_Width' cannot be null.");
        else if (configuration_Width !== undefined)
            url_ += "Configuration.Width=" + encodeURIComponent("" + configuration_Width) + "&";
        if (configuration_Height === null)
            throw new Error("The parameter 'configuration_Height' cannot be null.");
        else if (configuration_Height !== undefined)
            url_ += "Configuration.Height=" + encodeURIComponent("" + configuration_Height) + "&";
        if (configuration_MaxWidth === null)
            throw new Error("The parameter 'configuration_MaxWidth' cannot be null.");
        else if (configuration_MaxWidth !== undefined)
            url_ += "Configuration.MaxWidth=" + encodeURIComponent("" + configuration_MaxWidth) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThumbnailsForContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThumbnailsForContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ICalculateThumbnailsOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ICalculateThumbnailsOutputDto>;
        }));
    }

    protected processGetThumbnailsForContent(response: HttpResponseBase): Observable<ICalculateThumbnailsOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalculateThumbnailsOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as ICalculateThumbnailsOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    checkIfBase64Exist(body: ICheckIfBase64ExistInputDto | undefined): Observable<ICheckIfBase64ExistOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchBase64/CheckIfBase64Exist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfBase64Exist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfBase64Exist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ICheckIfBase64ExistOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ICheckIfBase64ExistOutputDto>;
        }));
    }

    protected processCheckIfBase64Exist(response: HttpResponseBase): Observable<ICheckIfBase64ExistOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckIfBase64ExistOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as ICheckIfBase64ExistOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addParentReferenceForBase64(body: IAddParentReferenceToBase64InputDto | undefined): Observable<IBase64ReferenceDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchBase64/AddParentReferenceForBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddParentReferenceForBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddParentReferenceForBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IBase64ReferenceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IBase64ReferenceDto>;
        }));
    }

    protected processAddParentReferenceForBase64(response: HttpResponseBase): Observable<IBase64ReferenceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Base64ReferenceDto.fromJS(resultData200);
            return _observableOf(resultData200 as IBase64ReferenceDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    createReferenceForBase64(body: ICreateReferenceForBase64InputDto | undefined): Observable<IBase64ReferenceDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchBase64/CreateReferenceForBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReferenceForBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReferenceForBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IBase64ReferenceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IBase64ReferenceDto>;
        }));
    }

    protected processCreateReferenceForBase64(response: HttpResponseBase): Observable<IBase64ReferenceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Base64ReferenceDto.fromJS(resultData200);
            return _observableOf(resultData200 as IBase64ReferenceDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EnterpriseSearchInstructionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: IInstructionDto | undefined): Observable<IInstructionDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchInstruction/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IInstructionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IInstructionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IInstructionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstructionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IInstructionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<IInstructionDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchInstruction/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IInstructionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IInstructionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IInstructionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstructionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IInstructionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getAll(maxResultCount: number | undefined, skipCount: number | undefined): Observable<IPagedResultDtoOfInstructionDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchInstruction/GetAll?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfInstructionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfInstructionDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IPagedResultDtoOfInstructionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInstructionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfInstructionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: IInstructionDto | undefined): Observable<IInstructionDto> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchInstruction/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IInstructionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IInstructionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IInstructionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstructionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IInstructionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnterpriseSearchInstruction/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExcelImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param documentType (optional)
     * @param destination (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getMappings(documentType: string | undefined, destination: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfDocumentMappingModelDto> {
        let url_ = this.baseUrl + "/api/services/app/ExcelImport/GetMappings?";
        if (documentType === null)
            throw new Error("The parameter 'documentType' cannot be null.");
        else if (documentType !== undefined)
            url_ += "DocumentType=" + encodeURIComponent("" + documentType) + "&";
        if (destination === null)
            throw new Error("The parameter 'destination' cannot be null.");
        else if (destination !== undefined)
            url_ += "Destination=" + encodeURIComponent("" + destination) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMappings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMappings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfDocumentMappingModelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfDocumentMappingModelDto>;
        }));
    }

    protected processGetMappings(response: HttpResponseBase): Observable<IPagedResultDtoOfDocumentMappingModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDocumentMappingModelDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfDocumentMappingModelDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    importExcelToVdb(body: IImportDataFromExcelInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExcelImport/ImportExcelToVdb";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportExcelToVdb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportExcelToVdb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportExcelToVdb(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    createMapping(body: ICreateMappingInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExcelImport/CreateMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    createMappingFromDocument(body: ICreateMappingFromDocumentInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExcelImport/CreateMappingFromDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMappingFromDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMappingFromDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateMappingFromDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ImageDescriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    pushPullImageDescription(body: IDescribeImageTasksInputDto | undefined): Observable<IDescribeImageResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImageDescription/PushPullImageDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPushPullImageDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPushPullImageDescription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IDescribeImageResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IDescribeImageResultDto[]>;
        }));
    }

    protected processPushPullImageDescription(response: HttpResponseBase): Observable<IDescribeImageResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DescribeImageResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IDescribeImageResultDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param resultId (optional)
     * @return Success
     */
    getImageDesciptionResult(resultId: string | undefined): Observable<IDescribeImageResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImageDescription/GetImageDesciptionResult?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageDesciptionResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageDesciptionResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IDescribeImageResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IDescribeImageResultDto[]>;
        }));
    }

    protected processGetImageDesciptionResult(response: HttpResponseBase): Observable<IDescribeImageResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DescribeImageResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IDescribeImageResultDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    startImageProcessing(body: IDescribeImageTasksInputDto | undefined): Observable<IStartImageProcessingOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ImageDescription/StartImageProcessing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartImageProcessing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartImageProcessing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IStartImageProcessingOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IStartImageProcessingOutputDto>;
        }));
    }

    protected processStartImageProcessing(response: HttpResponseBase): Observable<IStartImageProcessingOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StartImageProcessingOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IStartImageProcessingOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    processImageDescription(body: IDescribeImageTasksInputDto | undefined): Observable<IDescribeImageResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ImageDescription/ProcessImageDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessImageDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessImageDescription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IDescribeImageResultDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IDescribeImageResultDto[]>;
        }));
    }

    protected processProcessImageDescription(response: HttpResponseBase): Observable<IDescribeImageResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DescribeImageResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IDescribeImageResultDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    describeImage(body: IDescribeImageInputDto | undefined): Observable<IDescribeImageOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ImageDescription/DescribeImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDescribeImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDescribeImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IDescribeImageOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IDescribeImageOutputDto>;
        }));
    }

    protected processDescribeImage(response: HttpResponseBase): Observable<IDescribeImageOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DescribeImageOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IDescribeImageOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param base64Image (optional)
     * @param includingOCR (optional)
     * @return Success
     */
    getSearchDescription(base64Image: string | undefined, includingOCR: boolean | undefined): Observable<IFullDescriptionImageOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ImageDescription/GetSearchDescription?";
        if (base64Image === null)
            throw new Error("The parameter 'base64Image' cannot be null.");
        else if (base64Image !== undefined)
            url_ += "Base64Image=" + encodeURIComponent("" + base64Image) + "&";
        if (includingOCR === null)
            throw new Error("The parameter 'includingOCR' cannot be null.");
        else if (includingOCR !== undefined)
            url_ += "IncludingOCR=" + encodeURIComponent("" + includingOCR) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearchDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearchDescription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IFullDescriptionImageOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IFullDescriptionImageOutputDto>;
        }));
    }

    protected processGetSearchDescription(response: HttpResponseBase): Observable<IFullDescriptionImageOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FullDescriptionImageOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IFullDescriptionImageOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class IMAPServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param onlyUnread (optional)
     * @param markAsRead (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getMessages(onlyUnread: boolean | undefined, markAsRead: boolean | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IPagedResultDtoOfMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/IMAP/GetMessages?";
        if (onlyUnread === null)
            throw new Error("The parameter 'onlyUnread' cannot be null.");
        else if (onlyUnread !== undefined)
            url_ += "OnlyUnread=" + encodeURIComponent("" + onlyUnread) + "&";
        if (markAsRead === null)
            throw new Error("The parameter 'markAsRead' cannot be null.");
        else if (markAsRead !== undefined)
            url_ += "MarkAsRead=" + encodeURIComponent("" + markAsRead) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfMessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfMessageDto>;
        }));
    }

    protected processGetMessages(response: HttpResponseBase): Observable<IPagedResultDtoOfMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMessageDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfMessageDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    saveMessagesAttachments(body: ISaveAttachmentsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IMAP/SaveMessagesAttachments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMessagesAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMessagesAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveMessagesAttachments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    saveMessageAttachments(body: IAttachmentsFromTheMessageInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IMAP/SaveMessageAttachments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMessageAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMessageAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveMessageAttachments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param messageId (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getAttachmentsFromTheMessageTask(messageId: number | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IPagedResultDtoOfAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/IMAP/GetAttachmentsFromTheMessageTask?";
        if (messageId === null)
            throw new Error("The parameter 'messageId' cannot be null.");
        else if (messageId !== undefined)
            url_ += "MessageId=" + encodeURIComponent("" + messageId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentsFromTheMessageTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentsFromTheMessageTask(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfAttachmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfAttachmentDto>;
        }));
    }

    protected processGetAttachmentsFromTheMessageTask(response: HttpResponseBase): Observable<IPagedResultDtoOfAttachmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAttachmentDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfAttachmentDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    markMessagesAsRead(body: IMarkMessagesReadInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IMAP/MarkMessagesAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkMessagesAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkMessagesAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkMessagesAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LogDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves all log dashboards.
     * @return Success
     */
    getDashboards(): Observable<ILogDashboardDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/GetDashboards";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto[]>;
        }));
    }

    protected processGetDashboards(response: HttpResponseBase): Observable<ILogDashboardDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LogDashboardDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as ILogDashboardDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieves all log dashboards with brief information.
     * @return Success
     */
    getAll(): Observable<ILogDashboardBriefDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/GetAll";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardBriefDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardBriefDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ILogDashboardBriefDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LogDashboardBriefDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as ILogDashboardBriefDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieves a log dashboard by ID.
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<ILogDashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ILogDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogDashboardDto.fromJS(resultData200);
            return _observableOf(resultData200 as ILogDashboardDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieves a log dashboard by selector.
     * @param input (optional) The selector of the log dashboard.
     * @return Success
     */
    getBySelector(input: string | undefined): Observable<ILogDashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/GetBySelector?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySelector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySelector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto>;
        }));
    }

    protected processGetBySelector(response: HttpResponseBase): Observable<ILogDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogDashboardDto.fromJS(resultData200);
            return _observableOf(resultData200 as ILogDashboardDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieves a log dashboard by execution definition ID.
     * @param id (optional)
     * @return Success
     */
    getByExecutionDefinition(id: string | undefined): Observable<ILogDashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/GetByExecutionDefinition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByExecutionDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByExecutionDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto>;
        }));
    }

    protected processGetByExecutionDefinition(response: HttpResponseBase): Observable<ILogDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogDashboardDto.fromJS(resultData200);
            return _observableOf(resultData200 as ILogDashboardDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new log dashboard.
     * @param body (optional) The log dashboard creation input.
     * @return Success
     */
    create(body: ICreateLogDashboardDto | undefined): Observable<ILogDashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ILogDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogDashboardDto.fromJS(resultData200);
            return _observableOf(resultData200 as ILogDashboardDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an existing log dashboard.
     * @param body (optional) The log dashboard update input.
     * @return Success
     */
    update(body: IUpdateLogDashboardDto | undefined): Observable<ILogDashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ILogDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogDashboardDto.fromJS(resultData200);
            return _observableOf(resultData200 as ILogDashboardDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes a log dashboard by ID.
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a field to a log dashboard.
     * @param body (optional) The log dashboard field creation input.
     * @return Success
     */
    addField(body: ICreateLogDashboardFieldDto | undefined): Observable<ILogDashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/AddField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto>;
        }));
    }

    protected processAddField(response: HttpResponseBase): Observable<ILogDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogDashboardDto.fromJS(resultData200);
            return _observableOf(resultData200 as ILogDashboardDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates a field in a log dashboard.
     * @param body (optional) The log dashboard field update input.
     * @return Success
     */
    updateField(body: IUpdateLogDashboardFieldDto | undefined): Observable<ILogDashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/UpdateField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto>;
        }));
    }

    protected processUpdateField(response: HttpResponseBase): Observable<ILogDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogDashboardDto.fromJS(resultData200);
            return _observableOf(resultData200 as ILogDashboardDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes a field from a log dashboard by ID.
     * @param id (optional)
     * @return Success
     */
    removeField(id: string | undefined): Observable<ILogDashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/LogDashboard/RemoveField?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ILogDashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ILogDashboardDto>;
        }));
    }

    protected processRemoveField(response: HttpResponseBase): Observable<ILogDashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogDashboardDto.fromJS(resultData200);
            return _observableOf(resultData200 as ILogDashboardDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class McoHealthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param bijgewerktNa (optional)
     * @return Success
     */
    getDeliveryStatus(bijgewerktNa: dayjs.Dayjs | undefined): Observable<IGetDeliveryStatusOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetDeliveryStatus?";
        if (bijgewerktNa === null)
            throw new Error("The parameter 'bijgewerktNa' cannot be null.");
        else if (bijgewerktNa !== undefined)
            url_ += "BijgewerktNa=" + encodeURIComponent(bijgewerktNa ? "" + bijgewerktNa.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeliveryStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeliveryStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetDeliveryStatusOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetDeliveryStatusOutputDto[]>;
        }));
    }

    protected processGetDeliveryStatus(response: HttpResponseBase): Observable<IGetDeliveryStatusOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDeliveryStatusOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetDeliveryStatusOutputDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param bijgewerktNa (optional)
     * @return Success
     */
    getCustomers(bijgewerktNa: dayjs.Dayjs | undefined): Observable<IGetCustomerOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetCustomers?";
        if (bijgewerktNa === null)
            throw new Error("The parameter 'bijgewerktNa' cannot be null.");
        else if (bijgewerktNa !== undefined)
            url_ += "BijgewerktNa=" + encodeURIComponent(bijgewerktNa ? "" + bijgewerktNa.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetCustomerOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetCustomerOutputDto[]>;
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<IGetCustomerOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCustomerOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetCustomerOutputDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param bijgewerktNa (optional)
     * @return Success
     */
    getItems(bijgewerktNa: dayjs.Dayjs | undefined): Observable<IGetItemOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetItems?";
        if (bijgewerktNa === null)
            throw new Error("The parameter 'bijgewerktNa' cannot be null.");
        else if (bijgewerktNa !== undefined)
            url_ += "BijgewerktNa=" + encodeURIComponent(bijgewerktNa ? "" + bijgewerktNa.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetItemOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetItemOutputDto[]>;
        }));
    }

    protected processGetItems(response: HttpResponseBase): Observable<IGetItemOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetItemOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetItemOutputDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    createOrder(body: ICreateOderInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/CreateOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    assignWebId(body: IAssignWebIdInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/AssignWebId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignWebId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignWebId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignWebId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPriceListB2B(): Observable<IGetPriceListOutputB2Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetPriceListB2B";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceListB2B(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceListB2B(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetPriceListOutputB2Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetPriceListOutputB2Dto[]>;
        }));
    }

    protected processGetPriceListB2B(response: HttpResponseBase): Observable<IGetPriceListOutputB2Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPriceListOutputB2Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetPriceListOutputB2Dto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPriceListB2E(): Observable<IGetPriceListOutputB2Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetPriceListB2E";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceListB2E(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceListB2E(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetPriceListOutputB2Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetPriceListOutputB2Dto[]>;
        }));
    }

    protected processGetPriceListB2E(response: HttpResponseBase): Observable<IGetPriceListOutputB2Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPriceListOutputB2Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetPriceListOutputB2Dto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPriceListB2F(): Observable<IGetPriceListOutputB2Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetPriceListB2F";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceListB2F(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceListB2F(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetPriceListOutputB2Dto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetPriceListOutputB2Dto[]>;
        }));
    }

    protected processGetPriceListB2F(response: HttpResponseBase): Observable<IGetPriceListOutputB2Dto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPriceListOutputB2Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetPriceListOutputB2Dto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPriceListB2C(): Observable<IGetPriceListOutputB2CDto[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetPriceListB2C";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceListB2C(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceListB2C(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetPriceListOutputB2CDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetPriceListOutputB2CDto[]>;
        }));
    }

    protected processGetPriceListB2C(response: HttpResponseBase): Observable<IGetPriceListOutputB2CDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPriceListOutputB2CDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetPriceListOutputB2CDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPriceAgreement(): Observable<IGetPriceAgreementOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetPriceAgreement";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceAgreement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceAgreement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetPriceAgreementOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetPriceAgreementOutputDto[]>;
        }));
    }

    protected processGetPriceAgreement(response: HttpResponseBase): Observable<IGetPriceAgreementOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetPriceAgreementOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetPriceAgreementOutputDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getImage(id: string | undefined): Observable<IGetImageOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetImage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetImageOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetImageOutputDto>;
        }));
    }

    protected processGetImage(response: HttpResponseBase): Observable<IGetImageOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetImageOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IGetImageOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param bijgewerktNa (optional)
     * @return Success
     */
    getInvoiceDetails(bijgewerktNa: dayjs.Dayjs | undefined): Observable<IGetInvoiceDetailsOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetInvoiceDetails?";
        if (bijgewerktNa === null)
            throw new Error("The parameter 'bijgewerktNa' cannot be null.");
        else if (bijgewerktNa !== undefined)
            url_ += "BijgewerktNa=" + encodeURIComponent(bijgewerktNa ? "" + bijgewerktNa.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetInvoiceDetailsOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetInvoiceDetailsOutput[]>;
        }));
    }

    protected processGetInvoiceDetails(response: HttpResponseBase): Observable<IGetInvoiceDetailsOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetInvoiceDetailsOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetInvoiceDetailsOutput[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param deb (optional)
     * @param invoiceNumber (optional)
     * @return Success
     */
    getInvoice(deb: string | undefined, invoiceNumber: string | undefined): Observable<IGetInvoiceOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/McoHealth/GetInvoice?";
        if (deb === null)
            throw new Error("The parameter 'deb' cannot be null.");
        else if (deb !== undefined)
            url_ += "deb=" + encodeURIComponent("" + deb) + "&";
        if (invoiceNumber === null)
            throw new Error("The parameter 'invoiceNumber' cannot be null.");
        else if (invoiceNumber !== undefined)
            url_ += "invoiceNumber=" + encodeURIComponent("" + invoiceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetInvoiceOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetInvoiceOutputDto>;
        }));
    }

    protected processGetInvoice(response: HttpResponseBase): Observable<IGetInvoiceOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInvoiceOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IGetInvoiceOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OnlineHelperServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param bookmark (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getOnlineHelperByBookmarkOverview(bookmark: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IOnlineHelperDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/GetOnlineHelperByBookmarkOverview?";
        if (bookmark === null)
            throw new Error("The parameter 'bookmark' cannot be null.");
        else if (bookmark !== undefined)
            url_ += "Bookmark=" + encodeURIComponent("" + bookmark) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnlineHelperByBookmarkOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnlineHelperByBookmarkOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IOnlineHelperDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IOnlineHelperDto>;
        }));
    }

    protected processGetOnlineHelperByBookmarkOverview(response: HttpResponseBase): Observable<IOnlineHelperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnlineHelperDto.fromJS(resultData200);
            return _observableOf(resultData200 as IOnlineHelperDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param bookmark (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getOnlineHelperByBookmarkForEdit(bookmark: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IOnlineHelperDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/GetOnlineHelperByBookmarkForEdit?";
        if (bookmark === null)
            throw new Error("The parameter 'bookmark' cannot be null.");
        else if (bookmark !== undefined)
            url_ += "Bookmark=" + encodeURIComponent("" + bookmark) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnlineHelperByBookmarkForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnlineHelperByBookmarkForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IOnlineHelperDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IOnlineHelperDto>;
        }));
    }

    protected processGetOnlineHelperByBookmarkForEdit(response: HttpResponseBase): Observable<IOnlineHelperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnlineHelperDto.fromJS(resultData200);
            return _observableOf(resultData200 as IOnlineHelperDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    saveAndPublish(body: IUpdateOnlineHelperDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/SaveAndPublish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAndPublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAndPublish(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveAndPublish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    publishOnlineHelper(body: IGetByBookmarkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/PublishOnlineHelper";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishOnlineHelper(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishOnlineHelper(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPublishOnlineHelper(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    checkOnlineHelperBookmarkIsExists(body: IIsBookmarkExistInputDto | undefined): Observable<IIsBookmarkExistOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/CheckOnlineHelperBookmarkIsExists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOnlineHelperBookmarkIsExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOnlineHelperBookmarkIsExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IIsBookmarkExistOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IIsBookmarkExistOutputDto>;
        }));
    }

    protected processCheckOnlineHelperBookmarkIsExists(response: HttpResponseBase): Observable<IIsBookmarkExistOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsBookmarkExistOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IIsBookmarkExistOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: ICreateOnlineHelperDto | undefined): Observable<IOnlineHelperDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IOnlineHelperDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IOnlineHelperDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IOnlineHelperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnlineHelperDto.fromJS(resultData200);
            return _observableOf(resultData200 as IOnlineHelperDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: IUpdateOnlineHelperDto | undefined): Observable<IOnlineHelperDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IOnlineHelperDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IOnlineHelperDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IOnlineHelperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnlineHelperDto.fromJS(resultData200);
            return _observableOf(resultData200 as IOnlineHelperDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    togglePublic(body: IUpdateOnlineHelperDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/TogglePublic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTogglePublic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTogglePublic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTogglePublic(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    toggleVisible(body: IUpdateOnlineHelperDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/ToggleVisible";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleVisible(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleVisible(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processToggleVisible(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getAll(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IPagedResultDtoOfOnlineHelperDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfOnlineHelperDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfOnlineHelperDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IPagedResultDtoOfOnlineHelperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOnlineHelperDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfOnlineHelperDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    isBookmarkPublicAvailable(body: IGetBookmarkInputDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/IsBookmarkPublicAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsBookmarkPublicAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsBookmarkPublicAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsBookmarkPublicAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as boolean);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getVisibleBookmarkOverview(): Observable<IBookmarkOverviewDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/GetVisibleBookmarkOverview";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVisibleBookmarkOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVisibleBookmarkOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IBookmarkOverviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IBookmarkOverviewDto>;
        }));
    }

    protected processGetVisibleBookmarkOverview(response: HttpResponseBase): Observable<IBookmarkOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookmarkOverviewDto.fromJS(resultData200);
            return _observableOf(resultData200 as IBookmarkOverviewDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPublicBookmarkOverview(): Observable<IBookmarkOverviewDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/GetPublicBookmarkOverview";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicBookmarkOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicBookmarkOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IBookmarkOverviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IBookmarkOverviewDto>;
        }));
    }

    protected processGetPublicBookmarkOverview(response: HttpResponseBase): Observable<IBookmarkOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookmarkOverviewDto.fromJS(resultData200);
            return _observableOf(resultData200 as IBookmarkOverviewDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @param bookmark (optional)
     * @return Success
     */
    deleteBookmark(id: string | undefined, bookmark: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/DeleteBookmark?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (bookmark === null)
            throw new Error("The parameter 'bookmark' cannot be null.");
        else if (bookmark !== undefined)
            url_ += "Bookmark=" + encodeURIComponent("" + bookmark) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBookmark(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBookmark(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBookmark(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<IOnlineHelperDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IOnlineHelperDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IOnlineHelperDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IOnlineHelperDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnlineHelperDto.fromJS(resultData200);
            return _observableOf(resultData200 as IOnlineHelperDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OnlineHelper/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProcessorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    setTimer(body: IProcessorWatcherTimerInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Processor/SetTimer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTimer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTimer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetTimer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param source (optional)
     * @return Success
     */
    getExclusionList(source: string | undefined): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/services/app/Processor/GetExclusionList?";
        if (source === null)
            throw new Error("The parameter 'source' cannot be null.");
        else if (source !== undefined)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExclusionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExclusionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processGetExclusionList(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as { [key: string]: string; });
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param appId (optional)
     * @return Success
     */
    getAllTargets(appId: string | undefined): Observable<IProcessorTargetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Processor/GetAllTargets?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTargets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTargets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorTargetDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorTargetDto[]>;
        }));
    }

    protected processGetAllTargets(response: HttpResponseBase): Observable<IProcessorTargetDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessorTargetDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IProcessorTargetDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional)
     * @param value (optional)
     * @param source (optional)
     * @return Success
     */
    setExclusionList(key: string | undefined, value: string | undefined, source: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Processor/SetExclusionList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        if (source === null)
            throw new Error("The parameter 'source' cannot be null.");
        else if (source !== undefined)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetExclusionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetExclusionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetExclusionList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional)
     * @param source (optional)
     * @return Success
     */
    removeFromExclusionList(key: string | undefined, source: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Processor/RemoveFromExclusionList?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (source === null)
            throw new Error("The parameter 'source' cannot be null.");
        else if (source !== undefined)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromExclusionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromExclusionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveFromExclusionList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    setMaintenanceMode(body: IProcessorMaintenanceModeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Processor/SetMaintenanceMode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetMaintenanceMode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetMaintenanceMode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetMaintenanceMode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param target (optional)
     * @return Success
     */
    getPostProcessorTargets(target: string | undefined): Observable<IPostProcessingTargetOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Processor/GetPostProcessorTargets?";
        if (target === null)
            throw new Error("The parameter 'target' cannot be null.");
        else if (target !== undefined)
            url_ += "Target=" + encodeURIComponent("" + target) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostProcessorTargets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostProcessorTargets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPostProcessingTargetOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPostProcessingTargetOutputDto>;
        }));
    }

    protected processGetPostProcessorTargets(response: HttpResponseBase): Observable<IPostProcessingTargetOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostProcessingTargetOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPostProcessingTargetOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProcessorDebugServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param processorId (optional)
     * @return Success
     */
    getSteps(processorId: string | undefined): Observable<IStepDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetSteps?";
        if (processorId === null)
            throw new Error("The parameter 'processorId' cannot be null.");
        else if (processorId !== undefined)
            url_ += "ProcessorId=" + encodeURIComponent("" + processorId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSteps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSteps(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IStepDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IStepDto[]>;
        }));
    }

    protected processGetSteps(response: HttpResponseBase): Observable<IStepDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StepDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IStepDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param processorId (optional)
     * @return Success
     */
    getOverview(processorId: string | undefined): Observable<IProcessorOverviewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetOverview?";
        if (processorId === null)
            throw new Error("The parameter 'processorId' cannot be null.");
        else if (processorId !== undefined)
            url_ += "ProcessorId=" + encodeURIComponent("" + processorId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOverview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOverview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorOverviewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorOverviewDto>;
        }));
    }

    protected processGetOverview(response: HttpResponseBase): Observable<IProcessorOverviewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessorOverviewDto.fromJS(resultData200);
            return _observableOf(resultData200 as IProcessorOverviewDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param processorId (optional)
     * @return Success
     */
    getDepenpencies(processorId: string | undefined): Observable<IProcessorDependency[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetDepenpencies?";
        if (processorId === null)
            throw new Error("The parameter 'processorId' cannot be null.");
        else if (processorId !== undefined)
            url_ += "ProcessorId=" + encodeURIComponent("" + processorId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepenpencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepenpencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorDependency[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorDependency[]>;
        }));
    }

    protected processGetDepenpencies(response: HttpResponseBase): Observable<IProcessorDependency[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessorDependency.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IProcessorDependency[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @param type (optional)
     * @return Success
     */
    getProcessorDependencyTree(id: string | undefined, type: string | undefined): Observable<IProcessorFlowDependencyOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetProcessorDependencyTree?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessorDependencyTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessorDependencyTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorFlowDependencyOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorFlowDependencyOutputDto>;
        }));
    }

    protected processGetProcessorDependencyTree(response: HttpResponseBase): Observable<IProcessorFlowDependencyOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessorFlowDependencyOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IProcessorFlowDependencyOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param processorDefinitionId (optional)
     * @param appName (optional)
     * @param stepName (optional)
     * @param definition (optional)
     * @return Success
     */
    getStepOutput(processorDefinitionId: string | undefined, appName: string | undefined, stepName: string | undefined, definition: string | undefined): Observable<IJobResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetStepOutput?";
        if (processorDefinitionId === null)
            throw new Error("The parameter 'processorDefinitionId' cannot be null.");
        else if (processorDefinitionId !== undefined)
            url_ += "ProcessorDefinitionId=" + encodeURIComponent("" + processorDefinitionId) + "&";
        if (appName === null)
            throw new Error("The parameter 'appName' cannot be null.");
        else if (appName !== undefined)
            url_ += "AppName=" + encodeURIComponent("" + appName) + "&";
        if (stepName === null)
            throw new Error("The parameter 'stepName' cannot be null.");
        else if (stepName !== undefined)
            url_ += "StepName=" + encodeURIComponent("" + stepName) + "&";
        if (definition === null)
            throw new Error("The parameter 'definition' cannot be null.");
        else if (definition !== undefined)
            url_ += "Definition=" + encodeURIComponent("" + definition) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStepOutput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStepOutput(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobResultOutput>;
        }));
    }

    protected processGetStepOutput(response: HttpResponseBase): Observable<IJobResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobResultOutput.fromJS(resultData200);
            return _observableOf(resultData200 as IJobResultOutput);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param processorDefinitionId (optional)
     * @param appName (optional)
     * @param modifyStepName (optional)
     * @param modifiedStep (optional)
     * @param definition (optional)
     * @return Success
     */
    getModifiedStepOutput(processorDefinitionId: string | undefined, appName: string | undefined, modifyStepName: string | undefined, modifiedStep: any | undefined, definition: string | undefined): Observable<IJobResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetModifiedStepOutput?";
        if (processorDefinitionId === null)
            throw new Error("The parameter 'processorDefinitionId' cannot be null.");
        else if (processorDefinitionId !== undefined)
            url_ += "ProcessorDefinitionId=" + encodeURIComponent("" + processorDefinitionId) + "&";
        if (appName === null)
            throw new Error("The parameter 'appName' cannot be null.");
        else if (appName !== undefined)
            url_ += "AppName=" + encodeURIComponent("" + appName) + "&";
        if (modifyStepName === null)
            throw new Error("The parameter 'modifyStepName' cannot be null.");
        else if (modifyStepName !== undefined)
            url_ += "ModifyStepName=" + encodeURIComponent("" + modifyStepName) + "&";
        if (modifiedStep === null)
            throw new Error("The parameter 'modifiedStep' cannot be null.");
        else if (modifiedStep !== undefined)
            url_ += "ModifiedStep=" + encodeURIComponent("" + modifiedStep) + "&";
        if (definition === null)
            throw new Error("The parameter 'definition' cannot be null.");
        else if (definition !== undefined)
            url_ += "Definition=" + encodeURIComponent("" + definition) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModifiedStepOutput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModifiedStepOutput(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IJobResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IJobResultOutput>;
        }));
    }

    protected processGetModifiedStepOutput(response: HttpResponseBase): Observable<IJobResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobResultOutput.fromJS(resultData200);
            return _observableOf(resultData200 as IJobResultOutput);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    runProcessorInStepOperationMode(body: IRunProcessorInStepOperationInputDto | undefined): Observable<IDebugOutputModel> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/RunProcessorInStepOperationMode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRunProcessorInStepOperationMode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunProcessorInStepOperationMode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IDebugOutputModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IDebugOutputModel>;
        }));
    }

    protected processRunProcessorInStepOperationMode(response: HttpResponseBase): Observable<IDebugOutputModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DebugOutputModel.fromJS(resultData200);
            return _observableOf(resultData200 as IDebugOutputModel);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    runProcessorAsyncInStepOperationMode(body: IRunProcessorInStepOperationInputDto | undefined): Observable<IRunProcessorInStepOperationOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/RunProcessorAsyncInStepOperationMode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRunProcessorAsyncInStepOperationMode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRunProcessorAsyncInStepOperationMode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IRunProcessorInStepOperationOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IRunProcessorInStepOperationOutputDto>;
        }));
    }

    protected processRunProcessorAsyncInStepOperationMode(response: HttpResponseBase): Observable<IRunProcessorInStepOperationOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RunProcessorInStepOperationOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IRunProcessorInStepOperationOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param processorExecutionDefinitionId (optional)
     * @param stepName (optional)
     * @param runId (optional)
     * @return Success
     */
    getStepResultFromLastRun(processorExecutionDefinitionId: string | undefined, stepName: string | undefined, runId: string | undefined): Observable<IStepOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetStepResultFromLastRun?";
        if (processorExecutionDefinitionId === null)
            throw new Error("The parameter 'processorExecutionDefinitionId' cannot be null.");
        else if (processorExecutionDefinitionId !== undefined)
            url_ += "ProcessorExecutionDefinitionId=" + encodeURIComponent("" + processorExecutionDefinitionId) + "&";
        if (stepName === null)
            throw new Error("The parameter 'stepName' cannot be null.");
        else if (stepName !== undefined)
            url_ += "StepName=" + encodeURIComponent("" + stepName) + "&";
        if (runId === null)
            throw new Error("The parameter 'runId' cannot be null.");
        else if (runId !== undefined)
            url_ += "RunId=" + encodeURIComponent("" + runId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStepResultFromLastRun(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStepResultFromLastRun(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IStepOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IStepOutputDto>;
        }));
    }

    protected processGetStepResultFromLastRun(response: HttpResponseBase): Observable<IStepOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StepOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IStepOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pedId (optional)
     * @return Success
     */
    getLastResult(pedId: string | undefined): Observable<IDebugOutputModel> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetLastResult?";
        if (pedId === null)
            throw new Error("The parameter 'pedId' cannot be null.");
        else if (pedId !== undefined)
            url_ += "pedId=" + encodeURIComponent("" + pedId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IDebugOutputModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IDebugOutputModel>;
        }));
    }

    protected processGetLastResult(response: HttpResponseBase): Observable<IDebugOutputModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DebugOutputModel.fromJS(resultData200);
            return _observableOf(resultData200 as IDebugOutputModel);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param processorExecutionDefinitionId (optional)
     * @param stepName (optional)
     * @param runId (optional)
     * @return Success
     */
    getProcessorStepResultFromLastRun(processorExecutionDefinitionId: string | undefined, stepName: string | undefined, runId: string | undefined): Observable<IProcessorStepOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/GetProcessorStepResultFromLastRun?";
        if (processorExecutionDefinitionId === null)
            throw new Error("The parameter 'processorExecutionDefinitionId' cannot be null.");
        else if (processorExecutionDefinitionId !== undefined)
            url_ += "ProcessorExecutionDefinitionId=" + encodeURIComponent("" + processorExecutionDefinitionId) + "&";
        if (stepName === null)
            throw new Error("The parameter 'stepName' cannot be null.");
        else if (stepName !== undefined)
            url_ += "StepName=" + encodeURIComponent("" + stepName) + "&";
        if (runId === null)
            throw new Error("The parameter 'runId' cannot be null.");
        else if (runId !== undefined)
            url_ += "RunId=" + encodeURIComponent("" + runId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessorStepResultFromLastRun(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessorStepResultFromLastRun(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorStepOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorStepOutputDto>;
        }));
    }

    protected processGetProcessorStepResultFromLastRun(response: HttpResponseBase): Observable<IProcessorStepOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessorStepOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IProcessorStepOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    setStepOutput(body: IUpdateStepOutputInputDto | undefined): Observable<IUpdateStepOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorDebug/SetStepOutput";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetStepOutput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetStepOutput(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IUpdateStepOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IUpdateStepOutputDto>;
        }));
    }

    protected processSetStepOutput(response: HttpResponseBase): Observable<IUpdateStepOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateStepOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IUpdateStepOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProcessorEngineLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param processorId (optional) Gets or sets the unique identifier of the processor.
     * @param tenantId (optional) Gets or sets the tenant ID associated with the processor.
     * @param appName (optional) Gets or sets the name of the application.
     * @param processorName (optional) Gets or sets the name of the processor.
     * @param startDate (optional) Gets or sets the start date for the log retrieval.
     * @param limit (optional) Gets or sets the limit on the number of log entries to retrieve.
     * @param level (optional) Gets or sets the log level type for filtering logs.
     * @param sortDescending (optional) Gets or sets a value indicating whether to sort the logs in descending order.
     * @return Success
     */
    getLogs(processorId: string | undefined, tenantId: number | undefined, appName: string | undefined, processorName: string | undefined, startDate: dayjs.Dayjs | undefined, limit: number | undefined, level: ProcessorEngineLogLevelType | undefined, sortDescending: boolean | undefined): Observable<IProcessorEngineLogOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorEngineLog/GetLogs?";
        if (processorId === null)
            throw new Error("The parameter 'processorId' cannot be null.");
        else if (processorId !== undefined)
            url_ += "ProcessorId=" + encodeURIComponent("" + processorId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (appName === null)
            throw new Error("The parameter 'appName' cannot be null.");
        else if (appName !== undefined)
            url_ += "AppName=" + encodeURIComponent("" + appName) + "&";
        if (processorName === null)
            throw new Error("The parameter 'processorName' cannot be null.");
        else if (processorName !== undefined)
            url_ += "ProcessorName=" + encodeURIComponent("" + processorName) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "Level=" + encodeURIComponent("" + level) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorEngineLogOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorEngineLogOutputDto[]>;
        }));
    }

    protected processGetLogs(response: HttpResponseBase): Observable<IProcessorEngineLogOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessorEngineLogOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IProcessorEngineLogOutputDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    queryLogs(body: IProcessorEngineLogQueryInput | undefined): Observable<IProcessorEngineLogDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorEngineLog/QueryLogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorEngineLogDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorEngineLogDto[]>;
        }));
    }

    protected processQueryLogs(response: HttpResponseBase): Observable<IProcessorEngineLogDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessorEngineLogDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IProcessorEngineLogDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    queryCountLogs(body: IProcessorEngineLogCountQueryInput | undefined): Observable<IProcessorEngineLogCountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProcessorEngineLog/QueryCountLogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryCountLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryCountLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorEngineLogCountDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorEngineLogCountDto[]>;
        }));
    }

    protected processQueryCountLogs(response: HttpResponseBase): Observable<IProcessorEngineLogCountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessorEngineLogCountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IProcessorEngineLogCountDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RemoteControlServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    popAssignment(body: IPopAssignmentInputDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/PopAssignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPopAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPopAssignment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPopAssignment(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as string);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param chanellId (optional)
     * @return Success
     */
    getAssignment(chanellId: string | undefined): Observable<IRemoteControlAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/GetAssignment?";
        if (chanellId === null)
            throw new Error("The parameter 'chanellId' cannot be null.");
        else if (chanellId !== undefined)
            url_ += "chanellId=" + encodeURIComponent("" + chanellId) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IRemoteControlAssignmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IRemoteControlAssignmentDto>;
        }));
    }

    protected processGetAssignment(response: HttpResponseBase): Observable<IRemoteControlAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteControlAssignmentDto.fromJS(resultData200);
            return _observableOf(resultData200 as IRemoteControlAssignmentDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    setAssignment(body: ISetAssignmentInputDto | undefined): Observable<ISetAssignmentOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/SetAssignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAssignment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ISetAssignmentOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ISetAssignmentOutputDto>;
        }));
    }

    protected processSetAssignment(response: HttpResponseBase): Observable<ISetAssignmentOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetAssignmentOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as ISetAssignmentOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    setDeliveries(body: IDeliveryInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/SetDeliveries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDeliveries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDeliveries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDeliveries(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getPagedResultQueryTemplate(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfQueryTemplatesDto> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/GetPagedResultQueryTemplate?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedResultQueryTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedResultQueryTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfQueryTemplatesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfQueryTemplatesDto>;
        }));
    }

    protected processGetPagedResultQueryTemplate(response: HttpResponseBase): Observable<IPagedResultDtoOfQueryTemplatesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQueryTemplatesDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfQueryTemplatesDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<IQueryTemplatesDto> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IQueryTemplatesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IQueryTemplatesDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IQueryTemplatesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryTemplatesDto.fromJS(resultData200);
            return _observableOf(resultData200 as IQueryTemplatesDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: ICreateQueryTemplateInputDto | undefined): Observable<IQueryTemplatesDto> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IQueryTemplatesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IQueryTemplatesDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IQueryTemplatesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryTemplatesDto.fromJS(resultData200);
            return _observableOf(resultData200 as IQueryTemplatesDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: IUpdateQueryTemplateInputDto | undefined): Observable<IQueryTemplatesDto> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IQueryTemplatesDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IQueryTemplatesDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IQueryTemplatesDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryTemplatesDto.fromJS(resultData200);
            return _observableOf(resultData200 as IQueryTemplatesDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RemoteControl/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TemplateManagerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    test(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TemplateManager/Test";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UrlActionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    applyAction(body: IApplyActionInputDto | undefined): Observable<IApplyActionOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/UrlActions/ApplyAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyAction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IApplyActionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IApplyActionOutputDto>;
        }));
    }

    protected processApplyAction(response: HttpResponseBase): Observable<IApplyActionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplyActionOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IApplyActionOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    isUrlLinkUsed(body: ICheckIfActionIsUsedInputDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/UrlActions/IsUrlLinkUsed";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUrlLinkUsed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUrlLinkUsed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUrlLinkUsed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as boolean);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: ICreateUrlActionInputDto | undefined): Observable<IUrlActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UrlActions/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IUrlActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IUrlActionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IUrlActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UrlActionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IUrlActionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    createUrlActionIfNotExist(body: ICreateUrlActionInputDto | undefined): Observable<IUrlActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UrlActions/CreateUrlActionIfNotExist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUrlActionIfNotExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUrlActionIfNotExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IUrlActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IUrlActionDto>;
        }));
    }

    protected processCreateUrlActionIfNotExist(response: HttpResponseBase): Observable<IUrlActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UrlActionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IUrlActionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    get(id: string | undefined): Observable<IUrlActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UrlActions/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IUrlActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IUrlActionDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IUrlActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UrlActionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IUrlActionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getAll(maxResultCount: number | undefined, skipCount: number | undefined): Observable<IPagedResultDtoOfUrlActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UrlActions/GetAll?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfUrlActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfUrlActionDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IPagedResultDtoOfUrlActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUrlActionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfUrlActionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    update(body: IUpdateUrlActionInputDto | undefined): Observable<IUrlActionDto> {
        let url_ = this.baseUrl + "/api/services/app/UrlActions/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IUrlActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IUrlActionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IUrlActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UrlActionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IUrlActionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UrlActions/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VDBServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional)
     * @return Success
     */
    saveToVirtualDb(body: ISaveToVirtualDbInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/SaveToVirtualDb";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveToVirtualDb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveToVirtualDb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveToVirtualDb(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    saveToVirtualDbInArray(body: ISaveToVirtualDbInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/SaveToVirtualDbInArray";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveToVirtualDbInArray(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveToVirtualDbInArray(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveToVirtualDbInArray(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getVirtualDbs(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfVirtualDbDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetVirtualDbs?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualDbs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualDbs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualDbDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualDbDto>;
        }));
    }

    protected processGetVirtualDbs(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualDbDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualDbDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualDbDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional)
     * @param databaseName (optional)
     * @param filterPropertyKey (optional)
     * @param filterPropertyValue (optional)
     * @param query (optional)
     * @param ignoreOnReadTtlUpdate (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getVirtualDbRows(filter: string | undefined, databaseName: string | undefined, filterPropertyKey: string | undefined, filterPropertyValue: string | undefined, query: string | undefined, ignoreOnReadTtlUpdate: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfVirtualDbRowDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetVirtualDbRows?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (filterPropertyKey === null)
            throw new Error("The parameter 'filterPropertyKey' cannot be null.");
        else if (filterPropertyKey !== undefined)
            url_ += "FilterPropertyKey=" + encodeURIComponent("" + filterPropertyKey) + "&";
        if (filterPropertyValue === null)
            throw new Error("The parameter 'filterPropertyValue' cannot be null.");
        else if (filterPropertyValue !== undefined)
            url_ += "FilterPropertyValue=" + encodeURIComponent("" + filterPropertyValue) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (ignoreOnReadTtlUpdate === null)
            throw new Error("The parameter 'ignoreOnReadTtlUpdate' cannot be null.");
        else if (ignoreOnReadTtlUpdate !== undefined)
            url_ += "IgnoreOnReadTtlUpdate=" + encodeURIComponent("" + ignoreOnReadTtlUpdate) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualDbRows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualDbRows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualDbRowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualDbRowDto>;
        }));
    }

    protected processGetVirtualDbRows(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualDbRowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualDbRowDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualDbRowDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional)
     * @param databaseName (optional)
     * @param filterPropertyKey (optional)
     * @param filterPropertyValue (optional)
     * @param query (optional)
     * @param ignoreOnReadTtlUpdate (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getVirtualDbRowsAsObject(filter: string | undefined, databaseName: string | undefined, filterPropertyKey: string | undefined, filterPropertyValue: string | undefined, query: string | undefined, ignoreOnReadTtlUpdate: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfVirtualDbRowJTokenDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetVirtualDbRowsAsObject?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (filterPropertyKey === null)
            throw new Error("The parameter 'filterPropertyKey' cannot be null.");
        else if (filterPropertyKey !== undefined)
            url_ += "FilterPropertyKey=" + encodeURIComponent("" + filterPropertyKey) + "&";
        if (filterPropertyValue === null)
            throw new Error("The parameter 'filterPropertyValue' cannot be null.");
        else if (filterPropertyValue !== undefined)
            url_ += "FilterPropertyValue=" + encodeURIComponent("" + filterPropertyValue) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (ignoreOnReadTtlUpdate === null)
            throw new Error("The parameter 'ignoreOnReadTtlUpdate' cannot be null.");
        else if (ignoreOnReadTtlUpdate !== undefined)
            url_ += "IgnoreOnReadTtlUpdate=" + encodeURIComponent("" + ignoreOnReadTtlUpdate) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualDbRowsAsObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualDbRowsAsObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualDbRowJTokenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualDbRowJTokenDto>;
        }));
    }

    protected processGetVirtualDbRowsAsObject(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualDbRowJTokenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualDbRowJTokenDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualDbRowJTokenDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional)
     * @param databaseName (optional)
     * @param filterPropertyKey (optional)
     * @param filterPropertyValue (optional)
     * @param query (optional)
     * @param ignoreOnReadTtlUpdate (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getSearchVirtualDbRowsAsObject(filter: string | undefined, databaseName: string | undefined, filterPropertyKey: string | undefined, filterPropertyValue: string | undefined, query: string | undefined, ignoreOnReadTtlUpdate: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfVirtualDbRowJTokenDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetSearchVirtualDbRowsAsObject?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (filterPropertyKey === null)
            throw new Error("The parameter 'filterPropertyKey' cannot be null.");
        else if (filterPropertyKey !== undefined)
            url_ += "FilterPropertyKey=" + encodeURIComponent("" + filterPropertyKey) + "&";
        if (filterPropertyValue === null)
            throw new Error("The parameter 'filterPropertyValue' cannot be null.");
        else if (filterPropertyValue !== undefined)
            url_ += "FilterPropertyValue=" + encodeURIComponent("" + filterPropertyValue) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (ignoreOnReadTtlUpdate === null)
            throw new Error("The parameter 'ignoreOnReadTtlUpdate' cannot be null.");
        else if (ignoreOnReadTtlUpdate !== undefined)
            url_ += "IgnoreOnReadTtlUpdate=" + encodeURIComponent("" + ignoreOnReadTtlUpdate) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearchVirtualDbRowsAsObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearchVirtualDbRowsAsObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualDbRowJTokenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualDbRowJTokenDto>;
        }));
    }

    protected processGetSearchVirtualDbRowsAsObject(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualDbRowJTokenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualDbRowJTokenDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualDbRowJTokenDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional)
     * @param databaseName (optional)
     * @param filterPropertyKey (optional)
     * @param filterPropertyValue (optional)
     * @param query (optional)
     * @param ignoreOnReadTtlUpdate (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getResolvedSearchVirtualDbRowsAsObject(filter: string | undefined, databaseName: string | undefined, filterPropertyKey: string | undefined, filterPropertyValue: string | undefined, query: string | undefined, ignoreOnReadTtlUpdate: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfVirtualDbRowJTokenDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetResolvedSearchVirtualDbRowsAsObject?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (filterPropertyKey === null)
            throw new Error("The parameter 'filterPropertyKey' cannot be null.");
        else if (filterPropertyKey !== undefined)
            url_ += "FilterPropertyKey=" + encodeURIComponent("" + filterPropertyKey) + "&";
        if (filterPropertyValue === null)
            throw new Error("The parameter 'filterPropertyValue' cannot be null.");
        else if (filterPropertyValue !== undefined)
            url_ += "FilterPropertyValue=" + encodeURIComponent("" + filterPropertyValue) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (ignoreOnReadTtlUpdate === null)
            throw new Error("The parameter 'ignoreOnReadTtlUpdate' cannot be null.");
        else if (ignoreOnReadTtlUpdate !== undefined)
            url_ += "IgnoreOnReadTtlUpdate=" + encodeURIComponent("" + ignoreOnReadTtlUpdate) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResolvedSearchVirtualDbRowsAsObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResolvedSearchVirtualDbRowsAsObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualDbRowJTokenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualDbRowJTokenDto>;
        }));
    }

    protected processGetResolvedSearchVirtualDbRowsAsObject(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualDbRowJTokenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualDbRowJTokenDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualDbRowJTokenDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional)
     * @param databaseName (optional)
     * @param filterPropertyKey (optional)
     * @param filterPropertyValue (optional)
     * @param query (optional)
     * @param ignoreOnReadTtlUpdate (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getSearchVirtualDbRows(filter: string | undefined, databaseName: string | undefined, filterPropertyKey: string | undefined, filterPropertyValue: string | undefined, query: string | undefined, ignoreOnReadTtlUpdate: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<IPagedResultDtoOfVirtualDbRowDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetSearchVirtualDbRows?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (filterPropertyKey === null)
            throw new Error("The parameter 'filterPropertyKey' cannot be null.");
        else if (filterPropertyKey !== undefined)
            url_ += "FilterPropertyKey=" + encodeURIComponent("" + filterPropertyKey) + "&";
        if (filterPropertyValue === null)
            throw new Error("The parameter 'filterPropertyValue' cannot be null.");
        else if (filterPropertyValue !== undefined)
            url_ += "FilterPropertyValue=" + encodeURIComponent("" + filterPropertyValue) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (ignoreOnReadTtlUpdate === null)
            throw new Error("The parameter 'ignoreOnReadTtlUpdate' cannot be null.");
        else if (ignoreOnReadTtlUpdate !== undefined)
            url_ += "IgnoreOnReadTtlUpdate=" + encodeURIComponent("" + ignoreOnReadTtlUpdate) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSearchVirtualDbRows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSearchVirtualDbRows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualDbRowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualDbRowDto>;
        }));
    }

    protected processGetSearchVirtualDbRows(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualDbRowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualDbRowDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualDbRowDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional)
     * @param databaseName (optional)
     * @param filterPropertyKey (optional)
     * @param filterPropertyValue (optional)
     * @param hasFilter (optional)
     * @param ignoreOnReadTtlUpdate (optional)
     * @return Success
     */
    getVirtualDbRowValue(key: string | undefined, databaseName: string | undefined, filterPropertyKey: string | undefined, filterPropertyValue: string | undefined, hasFilter: boolean | undefined, ignoreOnReadTtlUpdate: boolean | undefined): Observable<IVirtualDbRowDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetVirtualDbRowValue?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (filterPropertyKey === null)
            throw new Error("The parameter 'filterPropertyKey' cannot be null.");
        else if (filterPropertyKey !== undefined)
            url_ += "FilterPropertyKey=" + encodeURIComponent("" + filterPropertyKey) + "&";
        if (filterPropertyValue === null)
            throw new Error("The parameter 'filterPropertyValue' cannot be null.");
        else if (filterPropertyValue !== undefined)
            url_ += "FilterPropertyValue=" + encodeURIComponent("" + filterPropertyValue) + "&";
        if (hasFilter === null)
            throw new Error("The parameter 'hasFilter' cannot be null.");
        else if (hasFilter !== undefined)
            url_ += "HasFilter=" + encodeURIComponent("" + hasFilter) + "&";
        if (ignoreOnReadTtlUpdate === null)
            throw new Error("The parameter 'ignoreOnReadTtlUpdate' cannot be null.");
        else if (ignoreOnReadTtlUpdate !== undefined)
            url_ += "IgnoreOnReadTtlUpdate=" + encodeURIComponent("" + ignoreOnReadTtlUpdate) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualDbRowValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualDbRowValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IVirtualDbRowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IVirtualDbRowDto>;
        }));
    }

    protected processGetVirtualDbRowValue(response: HttpResponseBase): Observable<IVirtualDbRowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VirtualDbRowDto.fromJS(resultData200);
            return _observableOf(resultData200 as IVirtualDbRowDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional)
     * @param databaseName (optional)
     * @param filterPropertyKey (optional)
     * @param filterPropertyValue (optional)
     * @param hasFilter (optional)
     * @param ignoreOnReadTtlUpdate (optional)
     * @return Success
     */
    getVirtualDbRowValueAsObject(key: string | undefined, databaseName: string | undefined, filterPropertyKey: string | undefined, filterPropertyValue: string | undefined, hasFilter: boolean | undefined, ignoreOnReadTtlUpdate: boolean | undefined): Observable<IVirtualDbRowJTokenDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetVirtualDbRowValueAsObject?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (filterPropertyKey === null)
            throw new Error("The parameter 'filterPropertyKey' cannot be null.");
        else if (filterPropertyKey !== undefined)
            url_ += "FilterPropertyKey=" + encodeURIComponent("" + filterPropertyKey) + "&";
        if (filterPropertyValue === null)
            throw new Error("The parameter 'filterPropertyValue' cannot be null.");
        else if (filterPropertyValue !== undefined)
            url_ += "FilterPropertyValue=" + encodeURIComponent("" + filterPropertyValue) + "&";
        if (hasFilter === null)
            throw new Error("The parameter 'hasFilter' cannot be null.");
        else if (hasFilter !== undefined)
            url_ += "HasFilter=" + encodeURIComponent("" + hasFilter) + "&";
        if (ignoreOnReadTtlUpdate === null)
            throw new Error("The parameter 'ignoreOnReadTtlUpdate' cannot be null.");
        else if (ignoreOnReadTtlUpdate !== undefined)
            url_ += "IgnoreOnReadTtlUpdate=" + encodeURIComponent("" + ignoreOnReadTtlUpdate) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualDbRowValueAsObject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualDbRowValueAsObject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IVirtualDbRowJTokenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IVirtualDbRowJTokenDto>;
        }));
    }

    protected processGetVirtualDbRowValueAsObject(response: HttpResponseBase): Observable<IVirtualDbRowJTokenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VirtualDbRowJTokenDto.fromJS(resultData200);
            return _observableOf(resultData200 as IVirtualDbRowJTokenDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param key (optional)
     * @param databaseName (optional)
     * @param filterPropertyKey (optional)
     * @param filterPropertyValue (optional)
     * @param hasFilter (optional)
     * @param ignoreOnReadTtlUpdate (optional)
     * @return Success
     */
    getFilteredDbRowValue(key: string | undefined, databaseName: string | undefined, filterPropertyKey: string | undefined, filterPropertyValue: string | undefined, hasFilter: boolean | undefined, ignoreOnReadTtlUpdate: boolean | undefined): Observable<IVirtualDbRowDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetFilteredDbRowValue?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (filterPropertyKey === null)
            throw new Error("The parameter 'filterPropertyKey' cannot be null.");
        else if (filterPropertyKey !== undefined)
            url_ += "FilterPropertyKey=" + encodeURIComponent("" + filterPropertyKey) + "&";
        if (filterPropertyValue === null)
            throw new Error("The parameter 'filterPropertyValue' cannot be null.");
        else if (filterPropertyValue !== undefined)
            url_ += "FilterPropertyValue=" + encodeURIComponent("" + filterPropertyValue) + "&";
        if (hasFilter === null)
            throw new Error("The parameter 'hasFilter' cannot be null.");
        else if (hasFilter !== undefined)
            url_ += "HasFilter=" + encodeURIComponent("" + hasFilter) + "&";
        if (ignoreOnReadTtlUpdate === null)
            throw new Error("The parameter 'ignoreOnReadTtlUpdate' cannot be null.");
        else if (ignoreOnReadTtlUpdate !== undefined)
            url_ += "IgnoreOnReadTtlUpdate=" + encodeURIComponent("" + ignoreOnReadTtlUpdate) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilteredDbRowValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilteredDbRowValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IVirtualDbRowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IVirtualDbRowDto>;
        }));
    }

    protected processGetFilteredDbRowValue(response: HttpResponseBase): Observable<IVirtualDbRowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VirtualDbRowDto.fromJS(resultData200);
            return _observableOf(resultData200 as IVirtualDbRowDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param processorId (optional)
     * @param params (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getVirtualDbRowsAfterModifiedDate(processorId: string | undefined, params: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IPagedResultDtoOfVirtualDbNameRowDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetVirtualDbRowsAfterModifiedDate?";
        if (processorId === null)
            throw new Error("The parameter 'processorId' cannot be null.");
        else if (processorId !== undefined)
            url_ += "ProcessorId=" + encodeURIComponent("" + processorId) + "&";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "Params=" + encodeURIComponent("" + params) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualDbRowsAfterModifiedDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualDbRowsAfterModifiedDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualDbNameRowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualDbNameRowDto>;
        }));
    }

    protected processGetVirtualDbRowsAfterModifiedDate(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualDbNameRowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualDbNameRowDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualDbNameRowDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param databaseName (optional)
     * @param key (optional)
     * @return Success
     */
    deleteVirtualDbKey(databaseName: string | undefined, key: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/DeleteVirtualDbKey?";
        if (databaseName === null)
            throw new Error("The parameter 'databaseName' cannot be null.");
        else if (databaseName !== undefined)
            url_ += "DatabaseName=" + encodeURIComponent("" + databaseName) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVirtualDbKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVirtualDbKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteVirtualDbKey(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateJsonViewSetting(body: IUpdateJsonViewSettingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/UpdateJsonViewSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateJsonViewSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateJsonViewSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateJsonViewSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    appendToVirtualDbEntry(body: IAddPropertyToVirtualDbInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/AppendToVirtualDbEntry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAppendToVirtualDbEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAppendToVirtualDbEntry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAppendToVirtualDbEntry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    registerDocumentInQueue(body: IRegisterDocumentInQueueInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/RegisterDocumentInQueue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterDocumentInQueue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterDocumentInQueue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegisterDocumentInQueue(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    exportVdbToCsv(body: IExportToCsvInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/ExportVdbToCsv";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportVdbToCsv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportVdbToCsv(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExportVdbToCsv(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getProcessorRunReport(): Observable<IVirtualDbRowJTokenDto> {
        let url_ = this.baseUrl + "/api/services/app/VDB/GetProcessorRunReport";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessorRunReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessorRunReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IVirtualDbRowJTokenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IVirtualDbRowJTokenDto>;
        }));
    }

    protected processGetProcessorRunReport(response: HttpResponseBase): Observable<IVirtualDbRowJTokenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VirtualDbRowJTokenDto.fromJS(resultData200);
            return _observableOf(resultData200 as IVirtualDbRowJTokenDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    createVDBPermission(body: ICreateOrUpdateVDBPermissionInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/CreateVDBPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVDBPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVDBPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateVDBPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteVDBPermission(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/DeleteVDBPermission?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVDBPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVDBPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteVDBPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    validatePermission(body: IVDBPermissionValidationInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/ValidatePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processValidatePermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    createPushService(body: ICreateOrUpdateVDBPushService | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/CreatePushService";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePushService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePushService(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePushService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    insertPushService(body: IVDBPushServiceInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VDB/InsertPushService";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertPushService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertPushService(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInsertPushService(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VirtualBankServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getVirtualBankAccountByUser(id: number | undefined): Observable<IVirtualBankAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/VirtualBank/GetVirtualBankAccountByUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualBankAccountByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualBankAccountByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IVirtualBankAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IVirtualBankAccountDto>;
        }));
    }

    protected processGetVirtualBankAccountByUser(response: HttpResponseBase): Observable<IVirtualBankAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VirtualBankAccountDto.fromJS(resultData200);
            return _observableOf(resultData200 as IVirtualBankAccountDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getVirtualBankAccountById(id: string | undefined): Observable<IVirtualBankAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/VirtualBank/GetVirtualBankAccountById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualBankAccountById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualBankAccountById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IVirtualBankAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IVirtualBankAccountDto>;
        }));
    }

    protected processGetVirtualBankAccountById(response: HttpResponseBase): Observable<IVirtualBankAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VirtualBankAccountDto.fromJS(resultData200);
            return _observableOf(resultData200 as IVirtualBankAccountDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    confirmReservedTransactions(body: IConfirmReservedTransactionInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VirtualBank/ConfirmReservedTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmReservedTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmReservedTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmReservedTransactions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTenantStats(): Observable<IGetTenantStatisticsOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/VirtualBank/GetTenantStats";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IGetTenantStatisticsOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IGetTenantStatisticsOutput[]>;
        }));
    }

    protected processGetTenantStats(response: HttpResponseBase): Observable<IGetTenantStatisticsOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetTenantStatisticsOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IGetTenantStatisticsOutput[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getBalance(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/VirtualBank/GetBalance";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(resultData200 as number);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getTransactions(sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IPagedResultDtoOfVirtualBankAccountTransactionDto> {
        let url_ = this.baseUrl + "/api/services/app/VirtualBank/GetTransactions?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualBankAccountTransactionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualBankAccountTransactionDto>;
        }));
    }

    protected processGetTransactions(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualBankAccountTransactionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualBankAccountTransactionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualBankAccountTransactionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<IPagedResultDtoOfVirtualBankAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/VirtualBank/GetAll";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfVirtualBankAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfVirtualBankAccountDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IPagedResultDtoOfVirtualBankAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVirtualBankAccountDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfVirtualBankAccountDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllVirtualBankAccountIdWithOwnerId(): Observable<IPagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/VirtualBank/GetAllVirtualBankAccountIdWithOwnerId";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVirtualBankAccountIdWithOwnerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVirtualBankAccountIdWithOwnerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto>;
        }));
    }

    protected processGetAllVirtualBankAccountIdWithOwnerId(response: HttpResponseBase): Observable<IPagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WorkFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get list of processor execution definitions.
     * @return Success
     */
    getAll(): Observable<IProcessorExecutionDefinitionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlow/GetAll";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorExecutionDefinitionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorExecutionDefinitionDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IProcessorExecutionDefinitionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessorExecutionDefinitionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IProcessorExecutionDefinitionDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get processor execution definition by ID.
     * @param id (optional) The ID of the processor execution definition.
     * @return Success
     */
    getExecutionDefinitionById(id: string | undefined): Observable<IProcessorExecutionDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlow/GetExecutionDefinitionById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExecutionDefinitionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExecutionDefinitionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorExecutionDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorExecutionDefinitionDto>;
        }));
    }

    protected processGetExecutionDefinitionById(response: HttpResponseBase): Observable<IProcessorExecutionDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessorExecutionDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IProcessorExecutionDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get existing channels.
     * @return Success
     */
    getExistingChannels(): Observable<IChannelDefinitionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlow/GetExistingChannels";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExistingChannels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExistingChannels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IChannelDefinitionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IChannelDefinitionDto[]>;
        }));
    }

    protected processGetExistingChannels(response: HttpResponseBase): Observable<IChannelDefinitionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChannelDefinitionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(resultData200 as IChannelDefinitionDto[]);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create or update processor execution definition.
     * @param body (optional) The processor execution definition to create or update.
     * @return Success
     */
    createOrUpdate(body: IProcessorExecutionDefinitionDto | undefined): Observable<IProcessorExecutionDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlow/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IProcessorExecutionDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IProcessorExecutionDefinitionDto>;
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<IProcessorExecutionDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessorExecutionDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IProcessorExecutionDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Backup processor definition.
     * @param body (optional) The processor execution definition to backup.
     * @return Success
     */
    backupProcessorDefinition(body: IProcessorExecutionDefinitionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlow/BackupProcessorDefinition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackupProcessorDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackupProcessorDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBackupProcessorDefinition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a processor execution definition by ID.
     * @param id (optional)
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlow/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Return list of ProcessorExecutionDefinition filtered by name or execution definition.
     * @param body (optional) The search criteria.
     * @return Success
     */
    searchExecutionDefinition(body: ISearchExecutionDefinitionDto | undefined): Observable<IPagedResultDtoOfProcessorExecutionDefinitionDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkFlow/SearchExecutionDefinition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchExecutionDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchExecutionDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IPagedResultDtoOfProcessorExecutionDefinitionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IPagedResultDtoOfProcessorExecutionDefinitionDto>;
        }));
    }

    protected processSearchExecutionDefinition(response: HttpResponseBase): Observable<IPagedResultDtoOfProcessorExecutionDefinitionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProcessorExecutionDefinitionDto.fromJS(resultData200);
            return _observableOf(resultData200 as IPagedResultDtoOfProcessorExecutionDefinitionDto);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

class GenericDto<T> {
    constructor(data?: T) {
        if (data) {
            for (const property in data) {
                if (data.hasOwnProperty(property)) {
                    (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    }

    init(data?: Partial<T>) {
        if (data) {
            for (const property in data) {
                (<any>this)[property] = data[property];
            }
        }
    }

    static fromJS<U>(data: any): GenericDto<U> {
        data = typeof data === 'object' ? data : {};
        let result = new GenericDto<U>();
        result.init(data);
        return result;
    }

    toJSON(): T {
        let data: any = {};
        for (const property in this) {
            if (this.hasOwnProperty(property)) {
                data[property] = (<any>this)[property];
            }
        }
        return data;
    }
}

export interface IAddDataToEnterpriseSearchInputDto {
    data: IEnterpriseSearchDataModelDto[] |  undefined;
}

export interface IAddParentReferenceToBase64InputDto {
    referenceId: string  |  undefined;
    parentId: string  |  undefined;
    date: dayjs.Dayjs;
    path: IEnterpriseSearchPathDto[] |  undefined;
}

export interface IAddPropertyToVirtualDbInputDto {
    virtualDbName: string  |  undefined;
    virtualDbKey: string  |  undefined;
    newProperty: string  |  undefined;
    ttl: number  |  undefined;
}

export interface IAdditionalInformationDto {
    name: string  |  undefined;
    dataType: DataType;
    value: string  |  undefined;
}

export interface IAdditionalPropertyDto {
    id: string;
    name: string  |  undefined;
    defaultValue: string  |  undefined;
    type: FieldTypes;
    linkedToChannel: boolean;
    required: boolean;
    useCache: boolean;
    isOwner: boolean;
}

export interface IAdditionalPropertyInputDto {
    name: string  |  undefined;
    defaultValue: string  |  undefined;
    type: FieldTypes;
    linkedToChannel: boolean;
    required: boolean;
    useCache: boolean;
    id: string  |  undefined;
}

export interface IApiCallHeaderesDto {
    id: string;
    name: string  |  undefined;
    value: string  |  undefined;
    apiCallId: string;
    tenantId: number  |  undefined;
    accessGranted: boolean;
}

export interface IApiCallHeadersDto {
    /** Gets or sets the name. */
    name: string  |  undefined;
    /** Gets or sets the value. */
    value: string  |  undefined;
    /** Gets or sets the API call identifier. */
    apiCallId: string;
    /** Gets or sets the tenant identifier. */
    tenantId: number  |  undefined;
}

export interface IApiCallInputDto {
    id: string;
    title: string  |  undefined;
    call: string  |  undefined;
    method: string  |  undefined;
    description: string  |  undefined;
    authenticationRequired: boolean;
    acceptHeader: string  |  undefined;
    requestHeader: string  |  undefined;
    body: string  |  undefined;
    outputMapping: string  |  undefined;
    apiCallHeaders: IApiCallHeaderesDto[] |  undefined;
    accessGranted: boolean;
    usedForAuthentication: boolean;
}

export interface IApiCallsOutputDto {
    id: string;
    title: string  |  undefined;
    call: string  |  undefined;
    method: string  |  undefined;
    description: string  |  undefined;
    applicationName: string  |  undefined;
    acceptHeader: string  |  undefined;
    requestHeader: string  |  undefined;
    body: string  |  undefined;
    headers: IApiCallHeaderesDto[] |  undefined;
    authenticationRequired: boolean;
    outputMapping: string  |  undefined;
    accessGranted: boolean;
    usedForAuthentication: boolean;
}

export interface IApiConnectionSettingDto {
    /** Gets or sets the tenant ID associated with the API connection. */
    tenantId: number;
    /** Gets or sets the connection string for the API connection. */
    connectionString: string  |  undefined;
    /** Gets or sets the token for the API connection. */
    token: string  |  undefined;
    /** Gets or sets the username for the API connection. */
    userName: string  |  undefined;
    /** Gets or sets the password for the API connection. */
    password: string  |  undefined;
    /** Gets or sets the ID of the channel definitions associated with the API connection. */
    channelDefinitionsId: string;
    /** Gets or sets the port for the API connection. */
    port: string  |  undefined;
    /** Gets or sets a value indicating whether the API connection is enabled. */
    islEnabled: boolean;
    /** Gets or sets the unique identifier of the API connection setting. */
    id: string;
    /** Gets or sets the unique identifier of the API definition associated with this connection setting. */
    apiDefinitionId: string;
}

export interface IAppAssignmentListDto {
    id: string;
    creationTime: dayjs.Dayjs;
    creatorUserId: number  |  undefined;
    lastModificationTime: dayjs.Dayjs  |  undefined;
    lastModifierUserId: number  |  undefined;
    isDeleted: boolean;
    deleterUserId: number  |  undefined;
    deletionTime: dayjs.Dayjs  |  undefined;
    title: string  |  undefined;
    name: string  |  undefined;
    description: string  |  undefined;
    imageCSS: string  |  undefined;
    baseUrl: string  |  undefined;
    authentication: AuthenticationMethod;
    appStatus: AppStatus;
    appAssignmentId: string;
    appId: string;
    applicationProperties: IAdditionalPropertyDto[] |  undefined;
    additionalInformation: IAdditionalInformationDto[] |  undefined;
    additionalDicProperties: { [key: string]: string; } | undefined;
}

export interface IAppAssignmentOutput {
}

export interface IAppCustomSettingDto {
    id: string;
    name: string  |  undefined;
    value: string  |  undefined;
    organizationUnitId: number  |  undefined;
    tenantId: number  |  undefined;
    appId: string  |  undefined;
    channelId: string  |  undefined;
}

export interface IAppDefinitionOutputDto {
    id: string;
    title: string  |  undefined;
    name: string  |  undefined;
    description: string  |  undefined;
    imageCSS: string  |  undefined;
    authentication: AuthenticationMethod;
    baseUrl: string  |  undefined;
    appDefinitionType: string  |  undefined;
    availability: AppStatus;
    additionalProperties: string  |  undefined;
    additionalDicProperties: { [key: string]: string; } | undefined;
    price: number;
}

export interface IAppListDto {
    id: string;
    creationTime: dayjs.Dayjs;
    creatorUserId: number  |  undefined;
    lastModificationTime: dayjs.Dayjs  |  undefined;
    lastModifierUserId: number  |  undefined;
    isDeleted: boolean;
    deleterUserId: number  |  undefined;
    deletionTime: dayjs.Dayjs  |  undefined;
    title: string  |  undefined;
    name: string  |  undefined;
    description: string  |  undefined;
    imageCSS: string  |  undefined;
    appStatus: AppStatus;
    baseUrl: string  |  undefined;
    price: number;
    authentication: AuthenticationMethod;
    additionalDicProperties: { [key: string]: string; } | undefined;
}

export interface IAppPaymentDto {
    id: string;
    creationTime: dayjs.Dayjs;
    creatorUserId: number  |  undefined;
    lastModificationTime: dayjs.Dayjs  |  undefined;
    lastModifierUserId: number  |  undefined;
    isDeleted: boolean;
    deleterUserId: number  |  undefined;
    deletionTime: dayjs.Dayjs  |  undefined;
    /** Gets or sets the amount. */
    amount: number;
    /** Gets or sets the channel identifier. */
    channelId: string;
    paymentState: AppPaymentState;
    /** Gets or sets the order identifier. */
    orderId: string;
    /** Gets or sets the external reference. */
    externalReference: string  |  undefined;
    /** Gets or sets a value indicating whether this Axilla.AppBase.Application.Payment.Dto.AppPaymentDto is recurring. */
    recurring: boolean;
    direction: AppPaymentDirection;
    /** Gets or sets the name of the contact. */
    contactName: string  |  undefined;
    /** Gets or sets the contact email address. */
    contactEmailAddress: string  |  undefined;
    /** Gets or sets the address. */
    address: string  |  undefined;
    /** Gets or sets the address house number. */
    addressHouseNumber: string  |  undefined;
    /** Gets or sets the address apartment. */
    addressApartment: string  |  undefined;
    /** Gets or sets the address postcode. */
    addressPostcode: string  |  undefined;
    /** Gets or sets the address code. */
    addressCode: string  |  undefined;
    /** Gets or sets the address city. */
    addressCity: string  |  undefined;
    /** Gets or sets the address country. */
    addressCountry: string  |  undefined;
    /** Gets or sets the address comment. */
    addressComment: string  |  undefined;
}

export interface IAppPaymentProviderDto {
    id: string;
    creationTime: dayjs.Dayjs;
    creatorUserId: number  |  undefined;
    lastModificationTime: dayjs.Dayjs  |  undefined;
    lastModifierUserId: number  |  undefined;
    isDeleted: boolean;
    deleterUserId: number  |  undefined;
    deletionTime: dayjs.Dayjs  |  undefined;
    /** Gets or sets the title. */
    title: string  |  undefined;
}

export interface IApplicationJobArgsInput {
    processorDefinitionId: string;
    appName: string  |  undefined;
    valueToStart: string  |  undefined;
    valuesToStart: IJobValuesInput[] |  undefined;
}

export interface IApplyActionInputDto {
    id: string;
    comment: string  |  undefined;
}

export interface IApplyActionOutputDto {
    response: string  |  undefined;
}

export interface IAssignWebIdInputDto {
    relatieID: string;
    contactID: string;
    relatieDebiteurNummer: string  |  undefined;
    webshopToegang: string  |  undefined;
}

export interface IAttachmentDto {
    attachmentName: string  |  undefined;
    messageId: number;
    content: string  |  undefined;
}

export interface IAttachmentsFromTheMessageInputDto {
    maxResultCount: number;
    skipCount: number;
    messageId: number;
}

export interface IAuthArguments {
    name: string  |  undefined;
    value: string  |  undefined;
}

export interface IBase64ParentReferenceDto {
    date: dayjs.Dayjs;
    parentId: string  |  undefined;
    mainParentId: string  |  undefined;
    source: string  |  undefined;
}

export interface IBase64ReferenceDto {
    id: string  |  undefined;
    hash: string  |  undefined;
    path: string  |  undefined;
    date: dayjs.Dayjs;
    type: string  |  undefined;
    parent: IBase64ParentReferenceDto[] |  undefined;
}

export interface IBaseDocumentDto {
    id: string  |  undefined;
    name: string  |  undefined;
}

export interface IBookmarkOverviewDto {
    bookmarks: string[]  |  undefined;
}

export interface ICalculateThumbnailsOutputDto {
    documentRootId: string  |  undefined;
    thumbnailsType: string  |  undefined;
    thumbnailContent: string  |  undefined;
    thumbnailContentType: string  |  undefined;
    configuration: IThumbnailsConfigurationDto;
}

export interface IChangeAppSettingInput {
    name: string  |  undefined;
    value: string  |  undefined;
    organizationUnitId: number  |  undefined;
    tenantId: number  |  undefined;
    channelId: string  |  undefined;
    appId: string  |  undefined;
    useCache: boolean;
}

export interface IChannelDefinitionDto {
    title: string  |  undefined;
    description: string  |  undefined;
    appDefinitionId: string;
    returnMapping: string  |  undefined;
    authenticationValid: boolean;
    organizationUnitId: number  |  undefined;
    gateway: boolean;
    id: string;
}

export interface ICheckIfActionIsUsedInputDto {
    id: string;
}

export interface ICheckIfBase64ExistInputDto {
    base64Content: string  |  undefined;
}

export interface ICheckIfBase64ExistOutputDto {
    exist: boolean;
    referenceId: string  |  undefined;
}

export interface ICheckIfExistInputDto {
    mainContextHashKey: string  |  undefined;
}

export interface ICheckIfExistOutputDto {
    exist: boolean;
}

export interface ICleanHistoryInputDto {
    searchId: string[]  |  undefined;
}

export interface IConfirmReservedTransactionInputDto {
    reservedAmount: number;
    description: string  |  undefined;
}

export interface IContextMenuActionDto {
    label: string  |  undefined;
    icon: string  |  undefined;
    externPostUrl: IExternPostUrlActionDto;
    processor: IProcessorActionDto;
}

export interface ICreateApiConnectionSettingDto {
    /** Gets or sets the tenant ID associated with the API connection. */
    tenantId: number;
    /** Gets or sets the connection string for the API connection. */
    connectionString: string  |  undefined;
    /** Gets or sets the token for the API connection. */
    token: string  |  undefined;
    /** Gets or sets the username for the API connection. */
    userName: string  |  undefined;
    /** Gets or sets the password for the API connection. */
    password: string  |  undefined;
    /** Gets or sets the ID of the channel definitions associated with the API connection. */
    channelDefinitionsId: string;
    /** Gets or sets the port for the API connection. */
    port: string  |  undefined;
    /** Gets or sets a value indicating whether the API connection is enabled. */
    islEnabled: boolean;
}

export interface ICreateApiInputDto {
    /** Gets or sets the identifier. */
    id: string;
    /** Gets or sets the title. */
    title: string;
    /** Gets or sets the call. */
    call: string;
    /** Gets or sets the method. */
    method: string  |  undefined;
    /** Gets or sets the description. */
    description: string  |  undefined;
    /** Gets or sets a value indicating whether [authentication required]. */
    authenticationRequired: boolean;
    /** Gets or sets the accept header. */
    acceptHeader: string  |  undefined;
    /** Gets or sets the request header. */
    requestHeader: string  |  undefined;
    /** Gets or sets the body. */
    body: string  |  undefined;
    /** Gets or sets the output mapping. */
    outputMapping: string  |  undefined;
    /** Gets or sets the API call headers. */
    apiCallHeaders: IApiCallHeadersDto[] |  undefined;
    /** Gets or sets the tenant identifier. */
    tenantId: number  |  undefined;
    /** Gets or sets a value indicating whether [allow null tenant]. */
    allowNullTenant: boolean;
    /** Shows if the call is used for authentication of the channel */
    usedForAuthentication: boolean;
}

export interface ICreateAppInput {
    title: string;
    name: string  |  undefined;
    description: string  |  undefined;
    imageCSS: string  |  undefined;
    appStatus: AppStatus;
    baseUrl: string  |  undefined;
    additionalProperties: { [key: string]: string; } | undefined;
    applicationProperties: IAdditionalPropertyInputDto[] |  undefined;
    price: number;
    authentication: AuthenticationMethod;
}

export interface ICreateAppPaymentDto {
    /** Gets or sets the amount. */
    amount: number;
    /** Gets or sets the channel identifier. */
    channelId: string;
    paymentState: AppPaymentState;
    /** Gets or sets the order identifier. */
    orderId: string;
    /** Gets or sets the external reference. */
    externalReference: string  |  undefined;
    /** Gets or sets a value indicating whether this Axilla.AppBase.Application.Payment.Dto.CreateAppPaymentDto is recurring. */
    recurring: boolean;
    direction: AppPaymentDirection;
}

export interface ICreateChannelDefinitionDto {
    title: string  |  undefined;
    description: string  |  undefined;
    appDefinitionId: string;
    returnMapping: string  |  undefined;
    authenticationValid: boolean;
    organizationUnitId: number  |  undefined;
    gateway: boolean;
}

export interface ICreateInputTemplateTypeDto {
    id: string  |  undefined;
    tenantId: number  |  undefined;
    /** The parent id of an template */
    templateParentId: string  |  undefined;
    name: string  |  undefined;
    priority: number;
    enabled: boolean;
    childsAllowed: boolean;
    /** For future usage. This property can be used when the service is overriden */
    additionalProperties: { [key: string]: string; } | undefined;
}

export interface ICreateJobDefinitionInput {
    startImmediately: boolean;
    channelId: string  |  undefined;
    startTime: dayjs.Dayjs  |  undefined;
    cron: string  |  undefined;
    jobName: string  |  undefined;
    workflowName: string  |  undefined;
    params: string  |  undefined;
    isDayly: boolean;
    processorExecutionDefinition: string  |  undefined;
}

export interface ICreateLogDashboardDto {
    /** Gets or sets the name of the log dashboard. */
    name: string  |  undefined;
    /** Gets or sets the data source of the log dashboard. */
    datasource: string  |  undefined;
    /** Gets or sets the selector for the log dashboard. */
    selector: string  |  undefined;
    /** Gets or sets the query for the log dashboard. */
    query: string  |  undefined;
    /** Gets or sets the tenant ID. */
    tenantId: number;
}

export interface ICreateLogDashboardFieldDto {
    displayName: string  |  undefined;
    type: FieldTypes;
    fieldSource: string  |  undefined;
    logDashboardId: string;
}

export interface ICreateMappingFromDocumentInputDto {
    content: string  |  undefined;
    documentType: string  |  undefined;
    destination: string  |  undefined;
    keyField: string  |  undefined;
}

export interface ICreateMappingInputDto {
    documentType: string  |  undefined;
    destination: string  |  undefined;
    keyField: string  |  undefined;
    mapping: any  |  undefined;
}

export interface ICreateNewChannelInput {
    installedAppGuid: string;
    code: string  |  undefined;
    password: string  |  undefined;
    username: string  |  undefined;
    domain: string  |  undefined;
    gateway: boolean;
    oauthArguments: IAuthArguments[] |  undefined;
}

export interface ICreateOderInputDto {
    debID: string  |  undefined;
    factDebID: string  |  undefined;
    verzendDebID: string  |  undefined;
    refer: string  |  undefined;
    refer1: string  |  undefined;
    orderDatum: dayjs.Dayjs;
    afLeverDatum: dayjs.Dayjs;
    magCode: string  |  undefined;
    selectieCode: string  |  undefined;
    betalingConditie: string  |  undefined;
    leverWijze: string  |  undefined;
    webOrderNumber: string  |  undefined;
    afleverNaam: string  |  undefined;
    afleverAdres1: string  |  undefined;
    afleverAdres2: string  |  undefined;
    afleverAdres3: string  |  undefined;
    afleverPostcode: string  |  undefined;
    afleverPlaats: string  |  undefined;
    afleverLand: string  |  undefined;
    afleverTelefoon: string  |  undefined;
    afleverContactNaam: string  |  undefined;
    afleverContactInitialen: string  |  undefined;
    afleverEmail: string  |  undefined;
    orderItems: IOrderItemsInputDto[] |  undefined;
}

export interface ICreateOnlineHelperDto {
    title: string  |  undefined;
    state: string  |  undefined;
    bookmark: string  |  undefined;
    language: string  |  undefined;
    innerText: string  |  undefined;
    allowPublic: boolean;
    isVisible: boolean;
    tenantId: number  |  undefined;
}

export interface ICreateOrEditAppInput {
    title: string;
    name: string  |  undefined;
    description: string  |  undefined;
    imageCSS: string  |  undefined;
    appStatus: AppStatus;
    baseUrl: string  |  undefined;
    additionalProperties: { [key: string]: string; } | undefined;
    applicationProperties: IAdditionalPropertyInputDto[] |  undefined;
    price: number;
    authentication: AuthenticationMethod;
    id: string  |  undefined;
}

export interface ICreateOrEditInputTemplateDto {
    id: string  |  undefined;
    /** The HTML template as a vase64 decoded string */
    template: string  |  undefined;
    /** The name of the template */
    name: string;
    templateTypeId: string;
    /** A description of the template */
    description: string  |  undefined;
    group: string  |  undefined;
    /** For future usage. This property can be used when the service is overriden */
    additionalProperties: { [key: string]: string; } | undefined;
    /** Specify if the new template is the new default template */
    isDefault: boolean;
}

export interface ICreateOrUpdateVDBPermissionInputDto {
    userid: number;
    vdbName: string  |  undefined;
    permissionLevel: VDBPermissionLevel;
}

export interface ICreateOrUpdateVDBPushService {
    key: string  |  undefined;
    database: string  |  undefined;
    objectMapping: any  |  undefined;
}

export interface ICreateQueryTemplateInputDto {
    name: string  |  undefined;
    description: string  |  undefined;
    target: string  |  undefined;
    command: string  |  undefined;
    action: string  |  undefined;
}

export interface ICreateReferenceForBase64InputDto {
    base64Content: string  |  undefined;
    parentId: string  |  undefined;
    documentType: string  |  undefined;
    pathToBase64: string  |  undefined;
    date: dayjs.Dayjs;
    path: IEnterpriseSearchPathDto[] |  undefined;
}

export interface ICreateUrlActionInputDto {
    referenceGuid: string;
    referenceId: number;
    referenceString: string  |  undefined;
    isUsed: boolean;
    sendId: string  |  undefined;
    receivingUserId: number;
    actionType: UrlActionType;
    processorExecutionId: string  |  undefined;
    configuration: string  |  undefined;
}

export interface IDebugOutputModel {
    processorActionBaseOutput: any  |  undefined;
    processorActionErrors: any  |  undefined;
    dataLookUp: any  |  undefined;
    globalDataLookup: any  |  undefined;
    currentRow: any  |  undefined;
    lastStepName: string  |  undefined;
    lastAction: string  |  undefined;
    currentStepName: string  |  undefined;
    processorInformation: any  |  undefined;
}

export interface IDeliveryInputDto {
    id: string;
    data: any  |  undefined;
    message: string  |  undefined;
    success: boolean;
    creationDate: dayjs.Dayjs;
}

export interface IDescribeImageInputDto {
    base64Image: string  |  undefined;
    includingOCR: boolean;
}

export interface IDescribeImageOutputDto {
    caption: string  |  undefined;
    detailCaption: string  |  undefined;
    fullCaption: string  |  undefined;
    denseRegionCaption: string  |  undefined;
}

export interface IDescribeImageResultDto {
    referenceId: string  |  undefined;
    imageTasks: IImageTasksDto;
    result: string  |  undefined;
}

export interface IDescribeImageTasksInputDto {
    referenceId: string  |  undefined;
    base64Image: string  |  undefined;
    selectedTasks: IImageTasksDto[] |  undefined;
}

export interface IDocumentCountDto {
    type: RelatedDocumentTypes;
    count: number;
}

export interface IDocumentMappingModelDto {
    key: string  |  undefined;
    destination: string  |  undefined;
    documentType: string  |  undefined;
    keyField: string  |  undefined;
    mapping: any  |  undefined;
}

export interface IEditInputTemplateTypeDto {
    id: string;
    name: string  |  undefined;
    priority: number  |  undefined;
    enabled: boolean  |  undefined;
    childsAllowed: boolean  |  undefined;
    /** For future usage. This property can be used when the service is overriden */
    additionalProperties: { [key: string]: string; } | undefined;
}

export interface IEnterpriseSearchDataModelDto {
    id: string  |  undefined;
    parentId: string  |  undefined;
    sourceKey: string  |  undefined;
    recipientKey: string  |  undefined;
    receiverKey: string  |  undefined;
    mainContextKey: string  |  undefined;
    mainContextHashKey: string  |  undefined;
    date: dayjs.Dayjs;
    userContext: string[]  |  undefined;
    source: string  |  undefined;
    type: string  |  undefined;
    content: string  |  undefined;
    title: string  |  undefined;
    path: IEnterpriseSearchPathDto[] |  undefined;
    sequence: number;
}

export interface IEnterpriseSearchDataToElasticModelDto {
    sourceKey: string  |  undefined;
    recipientKey: string  |  undefined;
    receiverKey: string  |  undefined;
    mainContextKey: string  |  undefined;
    id: string  |  undefined;
    parentId: string  |  undefined;
    date: dayjs.Dayjs;
    userContext: string[]  |  undefined;
    source: string  |  undefined;
    title: string  |  undefined;
    type: string  |  undefined;
    content: string  |  undefined;
    contentHash: string  |  undefined;
    hash: string[]  |  undefined;
    path: IEnterpriseSearchPathDto[] |  undefined;
    contextActions: IContextMenuActionDto[] |  undefined;
    thumbnail: string  |  undefined;
    documentCount: IDocumentCountDto[] |  undefined;
    protectedUser: number;
}

export interface IEnterpriseSearchItemsInputDto {
    maxResultCount: number;
    skipCount: number;
    content: string  |  undefined;
    contentBase64: string  |  undefined;
    filters: { [key: string]: string[]; } | undefined;
    searchInHistory: boolean;
    searchInHistoryId: string  |  undefined;
    visualSearch: boolean;
    sort: string  |  undefined;
    sortByDate: boolean;
    exactSearch: boolean;
    startDate: dayjs.Dayjs  |  undefined;
    endDate: dayjs.Dayjs  |  undefined;
}

export interface IEnterpriseSearchMetadataDto {
    searchId: string  |  undefined;
    searchTerm: string  |  undefined;
    searchTermBase64: string  |  undefined;
    visualSearch: boolean;
    date: dayjs.Dayjs;
    type: string[]  |  undefined;
    channel: string[]  |  undefined;
    exactSearch: boolean;
    startDate: dayjs.Dayjs  |  undefined;
    endDate: dayjs.Dayjs  |  undefined;
    sort: string  |  undefined;
    sortByDate: boolean;
    filters: { [key: string]: string[]; } | undefined;
    skip: number;
    maxResultCount: number;
    searchDescription: string  |  undefined;
}

export interface IEnterpriseSearchPathDto {
    id: string  |  undefined;
    source: string  |  undefined;
    type: string  |  undefined;
    title: string  |  undefined;
    date: dayjs.Dayjs;
}

export interface IEnterpriseSearchResultOutputDto {
    source: string  |  undefined;
    rId: string  |  undefined;
    creationDate: dayjs.Dayjs;
    context: string  |  undefined;
    content: string  |  undefined;
}

export interface IEntityDto {
    id: number;
}

export interface IEntityDtoOfGuid {
    id: string;
}

export interface IEntityDtoOfString {
    id: string  |  undefined;
}

export interface IExecuteApiCallInputDto {
    /** Specify the method or leave empty to use default GET */
    method: string  |  undefined;
    /** Specify the endpoint after the base url */
    url: string  |  undefined;
    /** Specify the authorization using channel */
    channelId: string;
    /** Specify the information to send */
    body: string  |  undefined;
    /** Specify the required headers to send the normal data operation will work (variables, transformation, ...) */
    headers: string  |  undefined;
    /** Format output in specific way. Currently allowed: null, json, jarray */
    outputFormating: string  |  undefined;
}

export interface IExecuteApiCallOutputDto {
    /** Code from response of the api call */
    resultCode: number;
    /** Content from response of the api call */
    result: any  |  undefined;
}

export interface IExportToCsvInput {
    vdbName: string  |  undefined;
    notificationGroup: string  |  undefined;
    emailAddress: string  |  undefined;
}

export interface IExternPostUrlActionDto {
    url: string  |  undefined;
    params: any  |  undefined;
}

export interface IFilterOptionDto {
    label: string  |  undefined;
    filterName: string  |  undefined;
    options: IFilterOptionValueDto[] |  undefined;
}

export interface IFilterOptionValueDto {
    value: string  |  undefined;
    displayName: string  |  undefined;
}

export interface IFullDescriptionImageOutputDto {
    fullCaption: string  |  undefined;
}

export interface IGetAllVirtualBankAccountOwnersIdOutputDto {
    virtualBankAccountId: string;
    userId: number  |  undefined;
}

export interface IGetBookmarkInputDto {
    bookmark: string  |  undefined;
}

export interface IGetByBookmarkInput {
    maxResultCount: number;
    skipCount: number;
    sorting: string  |  undefined;
    bookmark: string  |  undefined;
}

export interface IGetCustomerOutputDto {
    relatieGUID: string  |  undefined;
    relatieID: string  |  undefined;
    moederbedrijf: string  |  undefined;
    relatieDebiteurNummer: string  |  undefined;
    relatieType: string  |  undefined;
    relatieStatus: string  |  undefined;
    relatieNaam: string  |  undefined;
    relatieEmail: string  |  undefined;
    contactID: string  |  undefined;
    nieuwsbriefDatumAangepast: dayjs.Dayjs;
    webshopToegang: boolean;
    relatieWebshopID: string  |  undefined;
    relatieNieuwsBriefJ_N: boolean;
    relatieKorting: number;
    relatieBTWNummer: string  |  undefined;
    btwGelijkAanArtikel: string  |  undefined;
    relatieAanmaakDatum: dayjs.Dayjs;
    relatieAangemaaktDoor: string  |  undefined;
    relatieWijzigingsDatum: dayjs.Dayjs;
    relatieWijzigingsDoor: string  |  undefined;
    relatieBetalingsVoorwaarden: string  |  undefined;
    categorie02: string  |  undefined;
    categorie03: string  |  undefined;
    relatieClassificatieID: string  |  undefined;
    leverAdresID: string  |  undefined;
    leverAdresregel1: string  |  undefined;
    leverAdresregel2: string  |  undefined;
    leverAdresregel3: string  |  undefined;
    leverAdresPlaats: string  |  undefined;
    leverAdresLand: string  |  undefined;
    leverAdresPostcode: string  |  undefined;
    contactVoornaam: string  |  undefined;
    contactAchternaam: string  |  undefined;
    contactTussenvoegsels: string  |  undefined;
    contactVolledigeNaam: string  |  undefined;
    contactInitialen: string  |  undefined;
    contactGeslacht: string  |  undefined;
    factuurAdresID: string  |  undefined;
    factuurAdresregel1: string  |  undefined;
    factuurAdresregel2: string  |  undefined;
    factuurAdresregel3: string  |  undefined;
    factuurAdresPlaats: string  |  undefined;
    factuurAdresLand: string  |  undefined;
    factuurAdresPostcode: string  |  undefined;
    prijsLijst: string  |  undefined;
}

export interface IGetDeliveryStatusOutputDto {
    aanmaakDatum: dayjs.Dayjs;
    bijgewerktDatum: dayjs.Dayjs;
    leveringStatus: string  |  undefined;
    webOrderID: string  |  undefined;
    orderIDMCO: string  |  undefined;
    afgehandeld: string  |  undefined;
    regelnummer: number;
    artikelCode: string  |  undefined;
    artikelSoort: string  |  undefined;
    aantalInBestelling: number;
    aantalGeleverd: number;
}

export interface IGetImageOutputDto {
    fileName: string  |  undefined;
    base64File: string  |  undefined;
}

export interface IGetInvoiceDetailsOutput {
    factuurNummer: string  |  undefined;
    factuurType: string  |  undefined;
    factuurDatum: dayjs.Dayjs;
    webshopOrderNummer: string  |  undefined;
}

export interface IGetInvoiceOutputDto {
    fileName: string  |  undefined;
    base64File: string  |  undefined;
}

export interface IGetItemOutputDto {
    artikelGroep: number;
    artikelGroepCode: string  |  undefined;
    artikelCode: string  |  undefined;
    artikelOmschrijving: string  |  undefined;
    artikelSoort: string  |  undefined;
    artikelAssortiment: string  |  undefined;
    artikelAssortimentCode: string  |  undefined;
    assortimentGroep: string  |  undefined;
    globeClass_03: string  |  undefined;
    potformaat: string  |  undefined;
    eanCodering: string  |  undefined;
    doseervorm: string  |  undefined;
    verpakkingsInhoud: string  |  undefined;
    globeItemNumberField_03: number;
    activering: boolean;
    exclusief: boolean;
    voorwaarden: string  |  undefined;
    forecast: number;
    artikelAanmaakDatum: dayjs.Dayjs;
    artikelAangemaaktDoor: number;
    artikelGewijzigdDatum: dayjs.Dayjs;
    artikelGewijzigdDoor: number;
    artikelStandaardVerkoopPrijs: number;
    artikelBTWCode: string  |  undefined;
    artikelVerpakkingsAantal: number;
    artikelVerpakkingsEenheid: string  |  undefined;
    artikelVoorraad: number;
}

export interface IGetLastUserDocumentOutputDto {
    fileType: string  |  undefined;
    base64Content: string  |  undefined;
}

export interface IGetPriceAgreementOutputDto {
    relatieID: string  |  undefined;
    prijslijst: string  |  undefined;
    prijslijstGeldigVanaf: dayjs.Dayjs;
    prijslijstGeldigTot: dayjs.Dayjs;
    bijgewertDatum: dayjs.Dayjs;
    aangemaaktDatum: dayjs.Dayjs;
    retailPrijs: number;
    korting: number;
    nieuwePrijs: number;
    artikelCode: string  |  undefined;
}

export interface IGetPriceListOutputB2CDto {
    relatieID: string  |  undefined;
    prijslijst: string  |  undefined;
    prijsAfspraak: boolean;
    prijslijstGeldigVanaf: dayjs.Dayjs;
    prijslijstGeldigTot: dayjs.Dayjs;
    artikelCode: string  |  undefined;
    prijs: number;
}

export interface IGetPriceListOutputB2Dto {
    prijslijst: string  |  undefined;
    prijslijstGeldigVanaf: dayjs.Dayjs;
    prijslijstGeldigTot: dayjs.Dayjs;
    assortimentGroep: string  |  undefined;
    bijgewerktDatum: dayjs.Dayjs;
    aangemaaktDatum: dayjs.Dayjs;
    korting: number;
    artikelCode: string  |  undefined;
}

export interface IGetTenantStatisticsOutput {
    name: string  |  undefined;
    value: number;
    max: number;
    description: string  |  undefined;
    unit: string  |  undefined;
}

export interface IImageTasksDto {
    taskType: DescribeImageTaskTypeDto;
    taskPrompt: string  |  undefined;
}

export interface IImportDataFromExcelInputDto {
    keyField: string  |  undefined;
    documentType: string  |  undefined;
    destination: string  |  undefined;
    content: string  |  undefined;
    mapEverything: boolean;
}

export interface IInstructionDto {
    id: string;
    index: string  |  undefined;
    instruction: string  |  undefined;
    tenantId: number  |  undefined;
}

export interface IIsBookmarkExistInputDto {
    bookmark: string  |  undefined;
}

export interface IIsBookmarkExistOutputDto {
    isExist: boolean;
    bookmark: string  |  undefined;
}

export interface IJobArgsForModifyStepDto {
    processorDefinitionId: string;
    appName: string  |  undefined;
    modifyStepName: string  |  undefined;
    modifiedStep: any  |  undefined;
    definition: string  |  undefined;
}

export interface IJobArgsForStepResultDto {
    processorDefinitionId: string;
    appName: string  |  undefined;
    stepName: string  |  undefined;
    definition: string  |  undefined;
}

export interface IJobDefinitionDto {
    id: string;
    creationTime: dayjs.Dayjs;
    creatorUserId: number  |  undefined;
    lastModificationTime: dayjs.Dayjs  |  undefined;
    lastModifierUserId: number  |  undefined;
    isDeleted: boolean;
    deleterUserId: number  |  undefined;
    deletionTime: dayjs.Dayjs  |  undefined;
    channelId: string;
    jobName: string  |  undefined;
    externalJobId: string  |  undefined;
    params: string  |  undefined;
    result: string  |  undefined;
}

export interface IJobResultOutput {
    result: any  |  undefined;
}

export interface IJobValuesInput {
    dataSourceName: string  |  undefined;
    dataValues: string  |  undefined;
}

export interface IListResultDtoOfAppAssignmentListDto {
    items: IAppAssignmentListDto[] |  undefined;
}

export interface IListResultDtoOfAppListDto {
    items: IAppListDto[] |  undefined;
}

export interface ILogDashboardBriefDto {
    /** Gets or sets the unique identifier of the log dashboard. */
    id: string;
    /** Gets or sets the name of the log dashboard. */
    name: string  |  undefined;
    /** Gets or sets the data source of the log dashboard. */
    datasource: string  |  undefined;
    /** Gets or sets the selector for the log dashboard. */
    selector: string  |  undefined;
    /** Gets or sets the query for the log dashboard. */
    query: string  |  undefined;
    /** Gets or sets the tenant ID. */
    tenantId: number;
}

export interface ILogDashboardDto {
    /** Gets or sets the name of the log dashboard. */
    name: string  |  undefined;
    /** Gets or sets the data source of the log dashboard. */
    datasource: string  |  undefined;
    /** Gets or sets the selector for the log dashboard. */
    selector: string  |  undefined;
    /** Gets or sets the query for the log dashboard. */
    query: string  |  undefined;
    /** Gets or sets the list of log dashboard fields. */
    logDashboardField: ILogDashboardFieldDto[] |  undefined;
    /** Gets or sets the tenant ID. */
    tenantId: number;
    /** Gets or sets the unique identifier of the log dashboard. */
    id: string;
}

export interface ILogDashboardFieldDto {
    displayName: string  |  undefined;
    type: FieldTypes;
    fieldSource: string  |  undefined;
    id: string;
}

export interface ILoginData {
}

export interface ILoginOauth2 {
    loginUrl: string  |  undefined;
    loginMask: string  |  undefined;
}

export interface IMarkMessagesReadInputDto {
    messageIds: number[]  |  undefined;
}

export interface IMessageDto {
    text: string  |  undefined;
    id: number;
    attachments: IBaseDocumentDto[] |  undefined;
    date: dayjs.Dayjs;
    priority: string  |  undefined;
    importance: string  |  undefined;
    subject: string  |  undefined;
    fromName: string  |  undefined;
    fromAddress: string  |  undefined;
}

export interface IOnlineHelperDto {
    id: string;
    state: IOnlineHelperStateListDto;
    bookmark: string  |  undefined;
    version: number;
    language: string  |  undefined;
    innerText: string  |  undefined;
    allowPublic: boolean;
    isVisible: boolean;
    title: string  |  undefined;
    tenantId: number  |  undefined;
}

export interface IOnlineHelperStateListDto {
    id: number;
    name: string  |  undefined;
    iconClass: string  |  undefined;
}

export interface IOrderItemsInputDto {
    regelnummer: string  |  undefined;
    webOrderNumber: string  |  undefined;
    artikelCode: string  |  undefined;
    artikelSoort: string  |  undefined;
    prijslijst: string  |  undefined;
    aantalBesteld: number;
    nettoPrijs: number;
    brutoPrijs: number;
    korting: number;
    btwCode: string  |  undefined;
    omschrijving: string  |  undefined;
}

export interface IPagedResultDtoOfApiConnectionSettingDto {
    items: IApiConnectionSettingDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfAppPaymentDto {
    items: IAppPaymentDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfAttachmentDto {
    items: IAttachmentDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfChannelDefinitionDto {
    items: IChannelDefinitionDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfDocumentMappingModelDto {
    items: IDocumentMappingModelDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfEnterpriseSearchResultOutputDto {
    items: IEnterpriseSearchResultOutputDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto {
    items: IGetAllVirtualBankAccountOwnersIdOutputDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfInstructionDto {
    items: IInstructionDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfJobDefinitionDto {
    items: IJobDefinitionDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfMessageDto {
    items: IMessageDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfOnlineHelperDto {
    items: IOnlineHelperDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfPreviewDocumentOutputDto {
    items: IPreviewDocumentOutputDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfProcessorExecutionDefinitionDto {
    items: IProcessorExecutionDefinitionDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfQueryTemplatesDto {
    items: IQueryTemplatesDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfRegistrationInputDto {
    items: IRegistrationInputDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfTemplateDto {
    items: ITemplateDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfUrlActionDto {
    items: IUrlActionDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfVirtualBankAccountDto {
    items: IVirtualBankAccountDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfVirtualBankAccountTransactionDto {
    items: IVirtualBankAccountTransactionDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfVirtualDbDto {
    items: IVirtualDbDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfVirtualDbNameRowDto {
    items: IVirtualDbNameRowDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfVirtualDbRowDto {
    items: IVirtualDbRowDto[] |  undefined;
    totalCount: number;
}

export interface IPagedResultDtoOfVirtualDbRowJTokenDto {
    items: IVirtualDbRowJTokenDto[] |  undefined;
    totalCount: number;
}

export interface IPopAssignmentInputDto {
    key: string  |  undefined;
    contains: string  |  undefined;
}

export interface IPostProcessingTargetDto {
    target: string  |  undefined;
    processorName: string  |  undefined;
}

export interface IPostProcessingTargetOutputDto {
    targets: IPostProcessingTargetDto[] |  undefined;
}

export interface IPreviewDocumentOutputDto {
    content: string  |  undefined;
    contentType: string  |  undefined;
}

export interface IPreviewItemOutputDto {
    sourceKey: string  |  undefined;
    mainContextKey: string  |  undefined;
    id: string  |  undefined;
    recipientKey: string  |  undefined;
    receiverKey: string  |  undefined;
    type: string  |  undefined;
    title: string  |  undefined;
    contentRaw: string  |  undefined;
    content: string  |  undefined;
    thumbnail: string  |  undefined;
}

export interface IProcessorActionDto {
    id: string  |  undefined;
    params: any  |  undefined;
}

export interface IProcessorDependency {
    name: string  |  undefined;
    action: string  |  undefined;
    id: string  |  undefined;
    icon: string  |  undefined;
    text: string  |  undefined;
    input: boolean;
    output: boolean;
    group: ProcessorDependencyGroupEnum;
    type: string  |  undefined;
    title: string  |  undefined;
    description: string  |  undefined;
}

export interface IProcessorDependencyDto {
    label: string  |  undefined;
    expanded: boolean;
    children: IProcessorDependency[] |  undefined;
    id: string  |  undefined;
    type: string  |  undefined;
}

export interface IProcessorDto {
    appName: string  |  undefined;
    processorsNames: string[]  |  undefined;
}

export interface IProcessorEngineExceptionDto {
    /** Gets or sets the class name where the exception occurred. */
    className: string  |  undefined;
    /** Gets or sets the message of the exception. */
    message: string  |  undefined;
    /** Gets or sets the source of the exception. */
    source: string  |  undefined;
    /** Gets or sets the stack trace of the exception. */
    stackTraceString: string  |  undefined;
}

export interface IProcessorEngineLogCountDto {
    /** Gets or sets the time of the log entry. */
    time: dayjs.Dayjs;
    /** Gets or sets the number of errors at the specified time. */
    errors: number;
}

export interface IProcessorEngineLogCountQueryInput {
    /** Gets or sets the ID of the log dashboard. */
    logDashboardId: string;
    /** Gets or sets the selector for the log query. */
    selector: string  |  undefined;
    /** Gets or sets the query parameters as a dictionary of key-value pairs. */
    query: { [key: string]: string; } | undefined;
    /** Gets or sets the name of the field to count. */
    fieldName: string  |  undefined;
    /** Gets or sets the name of the timestamp field. */
    timeStampFieldName: string  |  undefined;
}

export interface IProcessorEngineLogDto {
    /** Gets or sets the log level (e.g., Info, Warning, Error). */
    level: string  |  undefined;
    /** Gets or sets the log message. */
    message: string  |  undefined;
    /** Gets or sets the timestamp of the log entry. */
    timestamp: dayjs.Dayjs;
    fields: IProcessorEngineLogFieldsDto;
    /** Gets or sets the exceptions associated with the log entry. */
    exceptions: IProcessorEngineExceptionDto[] |  undefined;
}

export interface IProcessorEngineLogFieldsDto {
    /** Gets or sets the action performed by the processor. */
    action: string  |  undefined;
    /** Gets or sets the tenant ID associated with the processor. */
    tenantId: number  |  undefined;
    /** Gets or sets the name of the application. */
    appName: string  |  undefined;
    /** Gets or sets the name of the machine where the processor is running. */
    machineName: string  |  undefined;
    /** Gets or sets the unique identifier of the processor. */
    processorId: string  |  undefined;
    /** Gets or sets the source context of the log entry. */
    sourceContext: string  |  undefined;
    /** Gets or sets the result code of the processor action. */
    resultCode: string  |  undefined;
    /** Gets or sets the method used by the processor. */
    method: string  |  undefined;
    /** Gets or sets the URL associated with the processor action. */
    url: string  |  undefined;
    /** Gets or sets the name of the channel used by the processor. */
    channelName: string  |  undefined;
}

export interface IProcessorEngineLogOutputDto {
    /** Gets or sets the log level (e.g., Info, Warning, Error). */
    level: string  |  undefined;
    /** Gets or sets the log message. */
    message: string  |  undefined;
    /** Gets or sets the timestamp of the log entry. */
    timestamp: dayjs.Dayjs;
    fields: IProcessorEngineLogFieldsDto;
    /** Gets or sets the exceptions associated with the log entry. */
    exceptions: IProcessorEngineExceptionDto[] |  undefined;
}

export interface IProcessorEngineLogQueryInput {
    /** Gets or sets the ID of the log dashboard. */
    logDashboardId: string;
    /** Gets or sets the selector for the log query. */
    selector: string  |  undefined;
    /** Gets or sets the query parameters as a dictionary of key-value pairs. */
    query: { [key: string]: string; } | undefined;
}

export interface IProcessorExecutionDefinitionDto {
    /** Id of the processor */
    id: string  |  undefined;
    /** ExecutionDefinition of the processor */
    executionDefinition: string  |  undefined;
    /** Name of the processor */
    name: string  |  undefined;
    /** Abbreviation of the processor */
    abbreviation: string  |  undefined;
    /** Color of the processor */
    color: string  |  undefined;
    /** Count of the processors which may execute in parallel */
    concurrent: string  |  undefined;
}

export interface IProcessorFlowDependencyOutputDto {
    id: string  |  undefined;
    type: string  |  undefined;
    dependingObjects: IProcessorDependencyDto[] |  undefined;
}

export interface IProcessorMaintenanceModeInputDto {
    mode: boolean;
    timeInMinutes: number;
    forTenantOnly: boolean;
}

export interface IProcessorOverviewDto {
    steps: IStepDto[] |  undefined;
    dependencies: IProcessorDependency[] |  undefined;
    relatedProcessors: IProcessorDependency[] |  undefined;
}

export interface IProcessorStepOutputDto {
    state: ProcessorStateEnum;
    stepName: string  |  undefined;
    vdbName: string  |  undefined;
    processorErrors: string[]  |  undefined;
}

export interface IProcessorTargetDto {
    id: string;
    appId: string;
    processorId: string;
    roleId: number;
    roleName: string  |  undefined;
    tenantId: number;
    classification: string  |  undefined;
    styleObject: string  |  undefined;
    description: string  |  undefined;
    format: string  |  undefined;
    destination: string  |  undefined;
    protocol: string  |  undefined;
}

export interface IProcessorWatcherTimerInput {
    names: string[]  |  undefined;
    time: number;
}

export interface IProtectDataFromESInputDto {
    id: string  |  undefined;
}

export interface IQueryTemplatesDto {
    id: string;
    creationTime: dayjs.Dayjs;
    creatorUserId: number  |  undefined;
    lastModificationTime: dayjs.Dayjs  |  undefined;
    lastModifierUserId: number  |  undefined;
    isDeleted: boolean;
    deleterUserId: number  |  undefined;
    deletionTime: dayjs.Dayjs  |  undefined;
    name: string  |  undefined;
    description: string  |  undefined;
    target: string  |  undefined;
    command: string  |  undefined;
    action: string  |  undefined;
    tenantId: number  |  undefined;
}

export interface IRegisterAIDocumentInputDto {
    aiAgentName: string  |  undefined;
    source: string  |  undefined;
    sessionInfo: string  |  undefined;
    documentBase64: string  |  undefined;
    documentType: string  |  undefined;
}

export interface IRegisterDocumentInQueueInput {
    documentId: string;
    documentType: string  |  undefined;
}

export interface IRegisterListThumbnailsInputDto {
    documentRootId: string  |  undefined;
    thumbnails: IRegistrationThumbnailsDto[] |  undefined;
}

export interface IRegisterThumbnailsInputDto {
    documentRootId: string  |  undefined;
    thumbnailsType: string  |  undefined;
    thumbnailPath: string  |  undefined;
    thumbnailContentType: string  |  undefined;
    configuration: IThumbnailsConfigurationDto;
}

export interface IRegistrationInputDto {
    name: string  |  undefined;
    creationDate: dayjs.Dayjs;
    group: string  |  undefined;
    subGroup: string  |  undefined;
    tenantId: number  |  undefined;
    archived: boolean;
    archiveDateTime: dayjs.Dayjs  |  undefined;
    chargingTenantId: number  |  undefined;
    processTime: ITimeSpan;
    message: string  |  undefined;
    associatedObject: string  |  undefined;
    associatedId: string  |  undefined;
    organizationUnitId: number  |  undefined;
}

export interface IRegistrationThumbnailsDto {
    thumbnailsType: string  |  undefined;
    thumbnailPath: string  |  undefined;
    thumbnailContentType: string  |  undefined;
    configuration: IThumbnailsConfigurationDto;
}

export interface IRemoteControlAssignmentDto {
    id: string;
    command: string  |  undefined;
    action: string  |  undefined;
    arguments: any  |  undefined;
    creationDate: dayjs.Dayjs;
    url: string  |  undefined;
    method: string  |  undefined;
    contentType: string  |  undefined;
    header: string  |  undefined;
    body: string  |  undefined;
}

export interface IRunProcessorInStepOperationInputDto {
    processorExecutionDefinitionId: string;
    startStepName: string  |  undefined;
    stopStepName: string  |  undefined;
}

export interface IRunProcessorInStepOperationOutputDto {
    start: boolean;
    runId: string  |  undefined;
}

export interface ISaveAttachmentsInputDto {
    onlyUnread: boolean;
    markAsRead: boolean;
}

export interface ISaveSchemaInput {
    apiCall_Id: string;
    translationScheme: string  |  undefined;
}

export interface ISaveToVirtualDbInput {
    innerObject: any  |  undefined;
    key: string  |  undefined;
    databaseName: string  |  undefined;
    ttl: number  |  undefined;
}

export interface ISearchExecutionDefinitionDto {
    maxResultCount: number;
    skipCount: number;
    /** Name or execution definition to search */
    filter: string  |  undefined;
}

export interface ISearchItemsInputDto {
    maxResultCount: number;
    skipCount: number;
    index: string  |  undefined;
    content: string  |  undefined;
    hash: string  |  undefined;
    context: string  |  undefined;
    creationDate: string  |  undefined;
    rId: string  |  undefined;
    source: string  |  undefined;
}

export interface ISearchResultDto {
    metadata: IEnterpriseSearchMetadataDto;
    data: IEnterpriseSearchDataToElasticModelDto[] |  undefined;
    totalFound: number;
    timeLine: ITimelineDto[] |  undefined;
}

export interface ISendTestEmailInputDto {
    to: string  |  undefined;
    template: string  |  undefined;
}

export interface ISetAssignmentInputDto {
    id: string;
    command: string  |  undefined;
    action: string  |  undefined;
    arguments: any  |  undefined;
    creationDate: dayjs.Dayjs;
    url: string  |  undefined;
    method: string  |  undefined;
    contentType: string  |  undefined;
    header: string  |  undefined;
    body: string  |  undefined;
    trigger: string  |  undefined;
    processor: string  |  undefined;
    target: string;
    channelId: string  |  undefined;
}

export interface ISetAssignmentOutputDto {
    id: string;
}

export interface IStartImageProcessingOutputDto {
    id: string  |  undefined;
}

export interface IStartProcessorJobInput {
    startImmediately: boolean;
    channelId: string  |  undefined;
    startTime: dayjs.Dayjs  |  undefined;
    cron: string  |  undefined;
    jobName: string  |  undefined;
    workflowName: string  |  undefined;
    params: string  |  undefined;
    isDayly: boolean;
    processorExecutionDefinition: string  |  undefined;
    processors: IProcessorDto[] |  undefined;
}

export interface IStepDto {
    stepName: string  |  undefined;
    stepType: string  |  undefined;
    stepDefinition: any  |  undefined;
    validation: string  |  undefined;
    processorName: string  |  undefined;
    origin: string  |  undefined;
    processorDependencies: string[]  |  undefined;
    stepDependencies: string[]  |  undefined;
    sourceDependencies: string[]  |  undefined;
}

export interface IStepOutputDto {
    stepName: string  |  undefined;
    data: any  |  undefined;
}

export interface ITemplateDto {
    id: string;
    /** The template as a base 64 encoding */
    template: string  |  undefined;
    /** The name of the template */
    name: string;
    /** A description of the template */
    description: string  |  undefined;
    /** The id fo the template type */
    templateTypeId: string;
    /** The name of the template type */
    templateTypeName: string  |  undefined;
    group: string  |  undefined;
    /** Specify if the template is the default template for the given template type */
    default: boolean;
}

export interface ITemplateTypeDto {
    id: string;
    creationTime: dayjs.Dayjs;
    creatorUserId: number  |  undefined;
    lastModificationTime: dayjs.Dayjs  |  undefined;
    lastModifierUserId: number  |  undefined;
    isDeleted: boolean;
    deleterUserId: number  |  undefined;
    deletionTime: dayjs.Dayjs  |  undefined;
    tenantId: number  |  undefined;
    templateTypes: ITemplateTypeDto[] |  undefined;
    name: string  |  undefined;
    priority: number;
    enabled: boolean;
    childsAllowed: boolean;
}

export interface IThumbnailsConfigurationDto {
    width: number  |  undefined;
    height: number  |  undefined;
    maxWidth: number  |  undefined;
}

export interface ITimeSpan {
    ticks: number;
    days: number;
    hours: number;
    milliseconds: number;
    microseconds: number;
    nanoseconds: number;
    minutes: number;
    seconds: number;
    totalDays: number;
    totalHours: number;
    totalMilliseconds: number;
    totalMicroseconds: number;
    totalNanoseconds: number;
    totalMinutes: number;
    totalSeconds: number;
}

export interface ITimelineDto {
    date: dayjs.Dayjs;
    items: number;
}

export interface ITokenizeTextContentInputDto {
    model: IEnterpriseSearchDataModelDto;
    split: boolean;
    generateParentItem: boolean;
    parentItem: string  |  undefined;
}

export interface ITokenizeTextContentOutputDto {
    content: IEnterpriseSearchDataModelDto[] |  undefined;
}

export interface IUpdateApiConnectionSettingDto {
    /** Gets or sets the tenant ID associated with the API connection. */
    tenantId: number;
    /** Gets or sets the connection string for the API connection. */
    connectionString: string  |  undefined;
    /** Gets or sets the token for the API connection. */
    token: string  |  undefined;
    /** Gets or sets the username for the API connection. */
    userName: string  |  undefined;
    /** Gets or sets the password for the API connection. */
    password: string  |  undefined;
    /** Gets or sets the ID of the channel definitions associated with the API connection. */
    channelDefinitionsId: string;
    /** Gets or sets the port for the API connection. */
    port: string  |  undefined;
    /** Gets or sets a value indicating whether the API connection is enabled. */
    islEnabled: boolean;
    /** Gets or sets the unique identifier of the API connection setting. */
    id: string;
    /** Gets or sets the unique identifier of the API definition associated with this connection setting. */
    apiDefinitionId: string;
}

export interface IUpdateChannelDefinitionDto {
    title: string  |  undefined;
    description: string  |  undefined;
    appDefinitionId: string;
    returnMapping: string  |  undefined;
    authenticationValid: boolean;
    organizationUnitId: number  |  undefined;
    gateway: boolean;
    id: string;
}

export interface IUpdateJobDefinitionInput {
    startImmediately: boolean;
    channelId: string  |  undefined;
    startTime: dayjs.Dayjs  |  undefined;
    cron: string  |  undefined;
    jobName: string  |  undefined;
    workflowName: string  |  undefined;
    params: string  |  undefined;
    isDayly: boolean;
    processorExecutionDefinition: string  |  undefined;
    id: string;
}

export interface IUpdateJsonViewSettingInput {
    value: string  |  undefined;
}

export interface IUpdateLogDashboardDto {
    /** Gets or sets the unique identifier of the log dashboard. */
    id: string;
    /** Gets or sets the name of the log dashboard. */
    name: string  |  undefined;
    /** Gets or sets the data source of the log dashboard. */
    datasource: string  |  undefined;
    /** Gets or sets the selector for the log dashboard. */
    selector: string  |  undefined;
    /** Gets or sets the query for the log dashboard. */
    query: string  |  undefined;
    /** Gets or sets the tenant ID. */
    tenantId: number;
}

export interface IUpdateLogDashboardFieldDto {
    displayName: string  |  undefined;
    type: FieldTypes;
    fieldSource: string  |  undefined;
    id: string;
}

export interface IUpdateOnlineHelperDto {
    id: string;
    state: string  |  undefined;
    bookmark: string  |  undefined;
    version: number  |  undefined;
    language: string  |  undefined;
    innerText: string  |  undefined;
    title: string  |  undefined;
    allowPublic: boolean;
    isVisible: boolean;
    tenantId: number  |  undefined;
}

export interface IUpdateQueryTemplateInputDto {
    id: string;
    creationTime: dayjs.Dayjs;
    creatorUserId: number  |  undefined;
    lastModificationTime: dayjs.Dayjs  |  undefined;
    lastModifierUserId: number  |  undefined;
    isDeleted: boolean;
    deleterUserId: number  |  undefined;
    deletionTime: dayjs.Dayjs  |  undefined;
    name: string  |  undefined;
    description: string  |  undefined;
    target: string  |  undefined;
    command: string  |  undefined;
    action: string  |  undefined;
}

export interface IUpdateStepOutputDto {
    result: boolean;
    message: string  |  undefined;
}

export interface IUpdateStepOutputInputDto {
    executionDefinitionId: string;
    stepName: string  |  undefined;
    stepData: any  |  undefined;
}

export interface IUpdateUrlActionInputDto {
    id: string;
    referenceGuid: string;
    referenceId: number;
    referenceString: string  |  undefined;
    isUsed: boolean;
    sendId: string  |  undefined;
    receivingUserId: number;
    actionType: UrlActionType;
    processorExecutionId: string  |  undefined;
    configuration: string  |  undefined;
}

export interface IUrlActionDto {
    id: string;
    referenceGuid: string;
    referenceId: number;
    referenceString: string  |  undefined;
    isUsed: boolean;
    sendId: string  |  undefined;
    receivingUserId: number;
    actionType: UrlActionType;
    processorExecutionId: string  |  undefined;
    configuration: string  |  undefined;
}

export interface IVDBPermissionValidationInputDto {
    vdbName: string  |  undefined;
    userId: number  |  undefined;
    requestedPermission: VDBPermissionLevel;
}

export interface IVDBPushServiceInputDto {
    key: string  |  undefined;
    data: any  |  undefined;
}

export interface IVirtualBankAccountDto {
    id: string;
    legalName: string  |  undefined;
    contactEmailAddress: string  |  undefined;
    contactName: string  |  undefined;
    address: string  |  undefined;
    addressHouseNumber: string  |  undefined;
    addressApartment: string  |  undefined;
    addressPostcode: string  |  undefined;
    addressCode: string  |  undefined;
    addressCity: string  |  undefined;
    addressCountry: string  |  undefined;
    addressComment: string  |  undefined;
    invoiceContactName: string  |  undefined;
    invoiceLegalName: string  |  undefined;
    invoiceAddress: string  |  undefined;
    invoiceAddressHouseNumber: string  |  undefined;
    invoiceAddressApartment: string  |  undefined;
    invoiceAddressPostcode: string  |  undefined;
    invoiceAddressCode: string  |  undefined;
    invoiceAddressCity: string  |  undefined;
    invoiceAddressCountry: string  |  undefined;
    invoiceAddressComment: string  |  undefined;
    deliveryContactName: string  |  undefined;
    deliveryLegalName: string  |  undefined;
    deliveryAddress: string  |  undefined;
    deliveryAddressHouseNumber: string  |  undefined;
    deliveryAddressApartment: string  |  undefined;
    deliveryAddressPostcode: string  |  undefined;
    deliveryAddressCode: string  |  undefined;
    deliveryAddressCity: string  |  undefined;
    deliveryAddressCountry: string  |  undefined;
    deliveryAddressComment: string  |  undefined;
    externalUserReference: string  |  undefined;
    phoneAvailability: boolean;
    phoneNumber: string  |  undefined;
    phoneNumberSecondary: string  |  undefined;
    registrationNo: string  |  undefined;
    personalRegistrationNo: string  |  undefined;
    accountNumber: string  |  undefined;
    accountBankName: string  |  undefined;
    accountSwift: string  |  undefined;
    accountBic: string  |  undefined;
    paymentTerms: string  |  undefined;
    accountRsin: string  |  undefined;
    invoiceEAddress: string  |  undefined;
    invoiceRememberEInvoiceAddress: string  |  undefined;
    taxVatNo: string  |  undefined;
    userId: number;
    userName: string  |  undefined;
}

export interface IVirtualBankAccountTransactionDto {
    id: string;
    invoiceId: string  |  undefined;
    bookingAmount: number;
    previousAmount: number;
    afterBookingAmount: number;
    reserved: boolean;
    reservedAmount: number;
    description: string  |  undefined;
    invoiceReference: string  |  undefined;
    creationTime: dayjs.Dayjs;
}

export interface IVirtualDbDto {
    name: string  |  undefined;
}

export interface IVirtualDbNameRowDto {
    row: string  |  undefined;
}

export interface IVirtualDbRowDto {
    key: string  |  undefined;
    value: string  |  undefined;
}

export interface IVirtualDbRowJTokenDto {
    key: string  |  undefined;
    value: any  |  undefined;
}

export interface IWriteDataInputDto {
    index: string  |  undefined;
    data: any[]  |  undefined;
}

export class AddDataToEnterpriseSearchInputDto extends GenericDto<IAddDataToEnterpriseSearchInputDto> {}

export class AddParentReferenceToBase64InputDto extends GenericDto<IAddParentReferenceToBase64InputDto> {}

export class AddPropertyToVirtualDbInputDto extends GenericDto<IAddPropertyToVirtualDbInputDto> {}

export class AdditionalInformationDto extends GenericDto<IAdditionalInformationDto> {}

export class AdditionalPropertyDto extends GenericDto<IAdditionalPropertyDto> {}

export class AdditionalPropertyInputDto extends GenericDto<IAdditionalPropertyInputDto> {}

export class ApiCallHeaderesDto extends GenericDto<IApiCallHeaderesDto> {}

export class ApiCallHeadersDto extends GenericDto<IApiCallHeadersDto> {}

export class ApiCallInputDto extends GenericDto<IApiCallInputDto> {}

export class ApiCallsOutputDto extends GenericDto<IApiCallsOutputDto> {}

export class ApiConnectionSettingDto extends GenericDto<IApiConnectionSettingDto> {}

export class AppAssignmentListDto extends GenericDto<IAppAssignmentListDto> {}

export class AppAssignmentOutput extends GenericDto<IAppAssignmentOutput> {}

export class AppCustomSettingDto extends GenericDto<IAppCustomSettingDto> {}

export class AppDefinitionOutputDto extends GenericDto<IAppDefinitionOutputDto> {}

export class AppListDto extends GenericDto<IAppListDto> {}

export class AppPaymentDto extends GenericDto<IAppPaymentDto> {}

export class AppPaymentProviderDto extends GenericDto<IAppPaymentProviderDto> {}

export class ApplicationJobArgsInput extends GenericDto<IApplicationJobArgsInput> {}

export class ApplyActionInputDto extends GenericDto<IApplyActionInputDto> {}

export class ApplyActionOutputDto extends GenericDto<IApplyActionOutputDto> {}

export class AssignWebIdInputDto extends GenericDto<IAssignWebIdInputDto> {}

export class AttachmentDto extends GenericDto<IAttachmentDto> {}

export class AttachmentsFromTheMessageInputDto extends GenericDto<IAttachmentsFromTheMessageInputDto> {}

export class AuthArguments extends GenericDto<IAuthArguments> {}

export class Base64ParentReferenceDto extends GenericDto<IBase64ParentReferenceDto> {}

export class Base64ReferenceDto extends GenericDto<IBase64ReferenceDto> {}

export class BaseDocumentDto extends GenericDto<IBaseDocumentDto> {}

export class BookmarkOverviewDto extends GenericDto<IBookmarkOverviewDto> {}

export class CalculateThumbnailsOutputDto extends GenericDto<ICalculateThumbnailsOutputDto> {}

export class ChangeAppSettingInput extends GenericDto<IChangeAppSettingInput> {}

export class ChannelDefinitionDto extends GenericDto<IChannelDefinitionDto> {}

export class CheckIfActionIsUsedInputDto extends GenericDto<ICheckIfActionIsUsedInputDto> {}

export class CheckIfBase64ExistInputDto extends GenericDto<ICheckIfBase64ExistInputDto> {}

export class CheckIfBase64ExistOutputDto extends GenericDto<ICheckIfBase64ExistOutputDto> {}

export class CheckIfExistInputDto extends GenericDto<ICheckIfExistInputDto> {}

export class CheckIfExistOutputDto extends GenericDto<ICheckIfExistOutputDto> {}

export class CleanHistoryInputDto extends GenericDto<ICleanHistoryInputDto> {}

export class ConfirmReservedTransactionInputDto extends GenericDto<IConfirmReservedTransactionInputDto> {}

export class ContextMenuActionDto extends GenericDto<IContextMenuActionDto> {}

export class CreateApiConnectionSettingDto extends GenericDto<ICreateApiConnectionSettingDto> {}

export class CreateApiInputDto extends GenericDto<ICreateApiInputDto> {}

export class CreateAppInput extends GenericDto<ICreateAppInput> {}

export class CreateAppPaymentDto extends GenericDto<ICreateAppPaymentDto> {}

export class CreateChannelDefinitionDto extends GenericDto<ICreateChannelDefinitionDto> {}

export class CreateInputTemplateTypeDto extends GenericDto<ICreateInputTemplateTypeDto> {}

export class CreateJobDefinitionInput extends GenericDto<ICreateJobDefinitionInput> {}

export class CreateLogDashboardDto extends GenericDto<ICreateLogDashboardDto> {}

export class CreateLogDashboardFieldDto extends GenericDto<ICreateLogDashboardFieldDto> {}

export class CreateMappingFromDocumentInputDto extends GenericDto<ICreateMappingFromDocumentInputDto> {}

export class CreateMappingInputDto extends GenericDto<ICreateMappingInputDto> {}

export class CreateNewChannelInput extends GenericDto<ICreateNewChannelInput> {}

export class CreateOderInputDto extends GenericDto<ICreateOderInputDto> {}

export class CreateOnlineHelperDto extends GenericDto<ICreateOnlineHelperDto> {}

export class CreateOrEditAppInput extends GenericDto<ICreateOrEditAppInput> {}

export class CreateOrEditInputTemplateDto extends GenericDto<ICreateOrEditInputTemplateDto> {}

export class CreateOrUpdateVDBPermissionInputDto extends GenericDto<ICreateOrUpdateVDBPermissionInputDto> {}

export class CreateOrUpdateVDBPushService extends GenericDto<ICreateOrUpdateVDBPushService> {}

export class CreateQueryTemplateInputDto extends GenericDto<ICreateQueryTemplateInputDto> {}

export class CreateReferenceForBase64InputDto extends GenericDto<ICreateReferenceForBase64InputDto> {}

export class CreateUrlActionInputDto extends GenericDto<ICreateUrlActionInputDto> {}

export class DebugOutputModel extends GenericDto<IDebugOutputModel> {}

export class DeliveryInputDto extends GenericDto<IDeliveryInputDto> {}

export class DescribeImageInputDto extends GenericDto<IDescribeImageInputDto> {}

export class DescribeImageOutputDto extends GenericDto<IDescribeImageOutputDto> {}

export class DescribeImageResultDto extends GenericDto<IDescribeImageResultDto> {}

export class DescribeImageTasksInputDto extends GenericDto<IDescribeImageTasksInputDto> {}

export class DocumentCountDto extends GenericDto<IDocumentCountDto> {}

export class DocumentMappingModelDto extends GenericDto<IDocumentMappingModelDto> {}

export class EditInputTemplateTypeDto extends GenericDto<IEditInputTemplateTypeDto> {}

export class EnterpriseSearchDataModelDto extends GenericDto<IEnterpriseSearchDataModelDto> {}

export class EnterpriseSearchDataToElasticModelDto extends GenericDto<IEnterpriseSearchDataToElasticModelDto> {}

export class EnterpriseSearchItemsInputDto extends GenericDto<IEnterpriseSearchItemsInputDto> {}

export class EnterpriseSearchMetadataDto extends GenericDto<IEnterpriseSearchMetadataDto> {}

export class EnterpriseSearchPathDto extends GenericDto<IEnterpriseSearchPathDto> {}

export class EnterpriseSearchResultOutputDto extends GenericDto<IEnterpriseSearchResultOutputDto> {}

export class EntityDto extends GenericDto<IEntityDto> {}

export class EntityDtoOfGuid extends GenericDto<IEntityDtoOfGuid> {}

export class EntityDtoOfString extends GenericDto<IEntityDtoOfString> {}

export class ExecuteApiCallInputDto extends GenericDto<IExecuteApiCallInputDto> {}

export class ExecuteApiCallOutputDto extends GenericDto<IExecuteApiCallOutputDto> {}

export class ExportToCsvInput extends GenericDto<IExportToCsvInput> {}

export class ExternPostUrlActionDto extends GenericDto<IExternPostUrlActionDto> {}

export class FilterOptionDto extends GenericDto<IFilterOptionDto> {}

export class FilterOptionValueDto extends GenericDto<IFilterOptionValueDto> {}

export class FullDescriptionImageOutputDto extends GenericDto<IFullDescriptionImageOutputDto> {}

export class GetAllVirtualBankAccountOwnersIdOutputDto extends GenericDto<IGetAllVirtualBankAccountOwnersIdOutputDto> {}

export class GetBookmarkInputDto extends GenericDto<IGetBookmarkInputDto> {}

export class GetByBookmarkInput extends GenericDto<IGetByBookmarkInput> {}

export class GetCustomerOutputDto extends GenericDto<IGetCustomerOutputDto> {}

export class GetDeliveryStatusOutputDto extends GenericDto<IGetDeliveryStatusOutputDto> {}

export class GetImageOutputDto extends GenericDto<IGetImageOutputDto> {}

export class GetInvoiceDetailsOutput extends GenericDto<IGetInvoiceDetailsOutput> {}

export class GetInvoiceOutputDto extends GenericDto<IGetInvoiceOutputDto> {}

export class GetItemOutputDto extends GenericDto<IGetItemOutputDto> {}

export class GetLastUserDocumentOutputDto extends GenericDto<IGetLastUserDocumentOutputDto> {}

export class GetPriceAgreementOutputDto extends GenericDto<IGetPriceAgreementOutputDto> {}

export class GetPriceListOutputB2CDto extends GenericDto<IGetPriceListOutputB2CDto> {}

export class GetPriceListOutputB2Dto extends GenericDto<IGetPriceListOutputB2Dto> {}

export class GetTenantStatisticsOutput extends GenericDto<IGetTenantStatisticsOutput> {}

export class ImageTasksDto extends GenericDto<IImageTasksDto> {}

export class ImportDataFromExcelInputDto extends GenericDto<IImportDataFromExcelInputDto> {}

export class InstructionDto extends GenericDto<IInstructionDto> {}

export class IsBookmarkExistInputDto extends GenericDto<IIsBookmarkExistInputDto> {}

export class IsBookmarkExistOutputDto extends GenericDto<IIsBookmarkExistOutputDto> {}

export class JobArgsForModifyStepDto extends GenericDto<IJobArgsForModifyStepDto> {}

export class JobArgsForStepResultDto extends GenericDto<IJobArgsForStepResultDto> {}

export class JobDefinitionDto extends GenericDto<IJobDefinitionDto> {}

export class JobResultOutput extends GenericDto<IJobResultOutput> {}

export class JobValuesInput extends GenericDto<IJobValuesInput> {}

export class ListResultDtoOfAppAssignmentListDto extends GenericDto<IListResultDtoOfAppAssignmentListDto> {}

export class ListResultDtoOfAppListDto extends GenericDto<IListResultDtoOfAppListDto> {}

export class LogDashboardBriefDto extends GenericDto<ILogDashboardBriefDto> {}

export class LogDashboardDto extends GenericDto<ILogDashboardDto> {}

export class LogDashboardFieldDto extends GenericDto<ILogDashboardFieldDto> {}

export class LoginData extends GenericDto<ILoginData> {}

export class LoginOauth2 extends GenericDto<ILoginOauth2> {}

export class MarkMessagesReadInputDto extends GenericDto<IMarkMessagesReadInputDto> {}

export class MessageDto extends GenericDto<IMessageDto> {}

export class OnlineHelperDto extends GenericDto<IOnlineHelperDto> {}

export class OnlineHelperStateListDto extends GenericDto<IOnlineHelperStateListDto> {}

export class OrderItemsInputDto extends GenericDto<IOrderItemsInputDto> {}

export class PagedResultDtoOfApiConnectionSettingDto extends GenericDto<IPagedResultDtoOfApiConnectionSettingDto> {}

export class PagedResultDtoOfAppPaymentDto extends GenericDto<IPagedResultDtoOfAppPaymentDto> {}

export class PagedResultDtoOfAttachmentDto extends GenericDto<IPagedResultDtoOfAttachmentDto> {}

export class PagedResultDtoOfChannelDefinitionDto extends GenericDto<IPagedResultDtoOfChannelDefinitionDto> {}

export class PagedResultDtoOfDocumentMappingModelDto extends GenericDto<IPagedResultDtoOfDocumentMappingModelDto> {}

export class PagedResultDtoOfEnterpriseSearchResultOutputDto extends GenericDto<IPagedResultDtoOfEnterpriseSearchResultOutputDto> {}

export class PagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto extends GenericDto<IPagedResultDtoOfGetAllVirtualBankAccountOwnersIdOutputDto> {}

export class PagedResultDtoOfInstructionDto extends GenericDto<IPagedResultDtoOfInstructionDto> {}

export class PagedResultDtoOfJobDefinitionDto extends GenericDto<IPagedResultDtoOfJobDefinitionDto> {}

export class PagedResultDtoOfMessageDto extends GenericDto<IPagedResultDtoOfMessageDto> {}

export class PagedResultDtoOfOnlineHelperDto extends GenericDto<IPagedResultDtoOfOnlineHelperDto> {}

export class PagedResultDtoOfPreviewDocumentOutputDto extends GenericDto<IPagedResultDtoOfPreviewDocumentOutputDto> {}

export class PagedResultDtoOfProcessorExecutionDefinitionDto extends GenericDto<IPagedResultDtoOfProcessorExecutionDefinitionDto> {}

export class PagedResultDtoOfQueryTemplatesDto extends GenericDto<IPagedResultDtoOfQueryTemplatesDto> {}

export class PagedResultDtoOfRegistrationInputDto extends GenericDto<IPagedResultDtoOfRegistrationInputDto> {}

export class PagedResultDtoOfTemplateDto extends GenericDto<IPagedResultDtoOfTemplateDto> {}

export class PagedResultDtoOfUrlActionDto extends GenericDto<IPagedResultDtoOfUrlActionDto> {}

export class PagedResultDtoOfVirtualBankAccountDto extends GenericDto<IPagedResultDtoOfVirtualBankAccountDto> {}

export class PagedResultDtoOfVirtualBankAccountTransactionDto extends GenericDto<IPagedResultDtoOfVirtualBankAccountTransactionDto> {}

export class PagedResultDtoOfVirtualDbDto extends GenericDto<IPagedResultDtoOfVirtualDbDto> {}

export class PagedResultDtoOfVirtualDbNameRowDto extends GenericDto<IPagedResultDtoOfVirtualDbNameRowDto> {}

export class PagedResultDtoOfVirtualDbRowDto extends GenericDto<IPagedResultDtoOfVirtualDbRowDto> {}

export class PagedResultDtoOfVirtualDbRowJTokenDto extends GenericDto<IPagedResultDtoOfVirtualDbRowJTokenDto> {}

export class PopAssignmentInputDto extends GenericDto<IPopAssignmentInputDto> {}

export class PostProcessingTargetDto extends GenericDto<IPostProcessingTargetDto> {}

export class PostProcessingTargetOutputDto extends GenericDto<IPostProcessingTargetOutputDto> {}

export class PreviewDocumentOutputDto extends GenericDto<IPreviewDocumentOutputDto> {}

export class PreviewItemOutputDto extends GenericDto<IPreviewItemOutputDto> {}

export class ProcessorActionDto extends GenericDto<IProcessorActionDto> {}

export class ProcessorDependency extends GenericDto<IProcessorDependency> {}

export class ProcessorDependencyDto extends GenericDto<IProcessorDependencyDto> {}

export class ProcessorDto extends GenericDto<IProcessorDto> {}

export class ProcessorEngineExceptionDto extends GenericDto<IProcessorEngineExceptionDto> {}

export class ProcessorEngineLogCountDto extends GenericDto<IProcessorEngineLogCountDto> {}

export class ProcessorEngineLogCountQueryInput extends GenericDto<IProcessorEngineLogCountQueryInput> {}

export class ProcessorEngineLogDto extends GenericDto<IProcessorEngineLogDto> {}

export class ProcessorEngineLogFieldsDto extends GenericDto<IProcessorEngineLogFieldsDto> {}

export class ProcessorEngineLogOutputDto extends GenericDto<IProcessorEngineLogOutputDto> {}

export class ProcessorEngineLogQueryInput extends GenericDto<IProcessorEngineLogQueryInput> {}

export class ProcessorExecutionDefinitionDto extends GenericDto<IProcessorExecutionDefinitionDto> {}

export class ProcessorFlowDependencyOutputDto extends GenericDto<IProcessorFlowDependencyOutputDto> {}

export class ProcessorMaintenanceModeInputDto extends GenericDto<IProcessorMaintenanceModeInputDto> {}

export class ProcessorOverviewDto extends GenericDto<IProcessorOverviewDto> {}

export class ProcessorStepOutputDto extends GenericDto<IProcessorStepOutputDto> {}

export class ProcessorTargetDto extends GenericDto<IProcessorTargetDto> {}

export class ProcessorWatcherTimerInput extends GenericDto<IProcessorWatcherTimerInput> {}

export class ProtectDataFromESInputDto extends GenericDto<IProtectDataFromESInputDto> {}

export class QueryTemplatesDto extends GenericDto<IQueryTemplatesDto> {}

export class RegisterAIDocumentInputDto extends GenericDto<IRegisterAIDocumentInputDto> {}

export class RegisterDocumentInQueueInput extends GenericDto<IRegisterDocumentInQueueInput> {}

export class RegisterListThumbnailsInputDto extends GenericDto<IRegisterListThumbnailsInputDto> {}

export class RegisterThumbnailsInputDto extends GenericDto<IRegisterThumbnailsInputDto> {}

export class RegistrationInputDto extends GenericDto<IRegistrationInputDto> {}

export class RegistrationThumbnailsDto extends GenericDto<IRegistrationThumbnailsDto> {}

export class RemoteControlAssignmentDto extends GenericDto<IRemoteControlAssignmentDto> {}

export class RunProcessorInStepOperationInputDto extends GenericDto<IRunProcessorInStepOperationInputDto> {}

export class RunProcessorInStepOperationOutputDto extends GenericDto<IRunProcessorInStepOperationOutputDto> {}

export class SaveAttachmentsInputDto extends GenericDto<ISaveAttachmentsInputDto> {}

export class SaveSchemaInput extends GenericDto<ISaveSchemaInput> {}

export class SaveToVirtualDbInput extends GenericDto<ISaveToVirtualDbInput> {}

export class SearchExecutionDefinitionDto extends GenericDto<ISearchExecutionDefinitionDto> {}

export class SearchItemsInputDto extends GenericDto<ISearchItemsInputDto> {}

export class SearchResultDto extends GenericDto<ISearchResultDto> {}

export class SendTestEmailInputDto extends GenericDto<ISendTestEmailInputDto> {}

export class SetAssignmentInputDto extends GenericDto<ISetAssignmentInputDto> {}

export class SetAssignmentOutputDto extends GenericDto<ISetAssignmentOutputDto> {}

export class StartImageProcessingOutputDto extends GenericDto<IStartImageProcessingOutputDto> {}

export class StartProcessorJobInput extends GenericDto<IStartProcessorJobInput> {}

export class StepDto extends GenericDto<IStepDto> {}

export class StepOutputDto extends GenericDto<IStepOutputDto> {}

export class TemplateDto extends GenericDto<ITemplateDto> {}

export class TemplateTypeDto extends GenericDto<ITemplateTypeDto> {}

export class ThumbnailsConfigurationDto extends GenericDto<IThumbnailsConfigurationDto> {}

export class TimeSpan extends GenericDto<ITimeSpan> {}

export class TimelineDto extends GenericDto<ITimelineDto> {}

export class TokenizeTextContentInputDto extends GenericDto<ITokenizeTextContentInputDto> {}

export class TokenizeTextContentOutputDto extends GenericDto<ITokenizeTextContentOutputDto> {}

export class UpdateApiConnectionSettingDto extends GenericDto<IUpdateApiConnectionSettingDto> {}

export class UpdateChannelDefinitionDto extends GenericDto<IUpdateChannelDefinitionDto> {}

export class UpdateJobDefinitionInput extends GenericDto<IUpdateJobDefinitionInput> {}

export class UpdateJsonViewSettingInput extends GenericDto<IUpdateJsonViewSettingInput> {}

export class UpdateLogDashboardDto extends GenericDto<IUpdateLogDashboardDto> {}

export class UpdateLogDashboardFieldDto extends GenericDto<IUpdateLogDashboardFieldDto> {}

export class UpdateOnlineHelperDto extends GenericDto<IUpdateOnlineHelperDto> {}

export class UpdateQueryTemplateInputDto extends GenericDto<IUpdateQueryTemplateInputDto> {}

export class UpdateStepOutputDto extends GenericDto<IUpdateStepOutputDto> {}

export class UpdateStepOutputInputDto extends GenericDto<IUpdateStepOutputInputDto> {}

export class UpdateUrlActionInputDto extends GenericDto<IUpdateUrlActionInputDto> {}

export class UrlActionDto extends GenericDto<IUrlActionDto> {}

export class VDBPermissionValidationInputDto extends GenericDto<IVDBPermissionValidationInputDto> {}

export class VDBPushServiceInputDto extends GenericDto<IVDBPushServiceInputDto> {}

export class VirtualBankAccountDto extends GenericDto<IVirtualBankAccountDto> {}

export class VirtualBankAccountTransactionDto extends GenericDto<IVirtualBankAccountTransactionDto> {}

export class VirtualDbDto extends GenericDto<IVirtualDbDto> {}

export class VirtualDbNameRowDto extends GenericDto<IVirtualDbNameRowDto> {}

export class VirtualDbRowDto extends GenericDto<IVirtualDbRowDto> {}

export class VirtualDbRowJTokenDto extends GenericDto<IVirtualDbRowJTokenDto> {}

export class WriteDataInputDto extends GenericDto<IWriteDataInputDto> {}

export enum AppPaymentDirection {
    Outgoing = 1,
    Incoming = 2,
}

export enum AppPaymentState {
    Opened = 1,
    Canceled = 2,
    Payed = 3,
    Expired = 4,
    Failed = 5,
}

export enum AppStatus {
    DEVELOPMENT = 0,
    TEST = 1,
    ACCEPTANCE = 2,
    BETA = 3,
    PRODUCTION = 4,
}

export enum AuthenticationMethod {
    Oauth2 = 0,
    Bearer = 1,
    PureHttp = 2,
    NoAuthentication = 4,
    BasicAuth = 5,
    Oauth = 6,
    Oauth_SHAMAC256 = 7,
    Smtp = 8,
    Token = 9,
    IMAP = 10,
    ApiKey = 11,
    SFTP = 12,
    Oauth2Twinfield = 13,
    CustomAuth = 99,
    Oauth2_Google = 101,
    NTLM = 200,
    OAUTH_NETSUITE = 601,
}

export enum DataType {
    STRING = 0,
    INT = 1,
    DATE = 2,
    BOOL = 3,
}

export enum DescribeImageTaskTypeDto {
    OCR = 0,
    OCR_WITH_REGION = 1,
    CAPTION = 2,
    DETAILED_CAPTION = 3,
    MORE_DETAILED_CAPTION = 4,
    OD = 5,
    DENSE_REGION_CAPTION = 6,
    REGION_PROPOSAL = 7,
    CUSTOM_TASK = 1000,
}

export enum FieldTypes {
    Text = 1,
    Number = 2,
    Date = 3,
    Datetime = 4,
    Checkbox = 5,
    Radio = 6,
    Currency = 7,
    Textarea = 8,
    Dropdown = 9,
    Image = 10,
}

export enum ProcessorDependencyGroupEnum {
    None = 0,
    RemoteControl = 1,
    InputTenantCache = 2,
    OutputTenantCache = 3,
    InputVdb = 4,
    OutputVdb = 5,
    ApiCall = 6,
    ApplicationService = 7,
    UpstreamProcessor = 8,
    DownstreamProcessor = 9,
    ErrorHandlingNotification = 10,
    ErrorHandlingStopWithOutput = 11,
    ErrorHandlingStopWithoutOutput = 12,
    ErrorHandlingJumpMode = 13,
    ErrorHandlingIgnore = 14,
    ErrorHandlingApply = 15,
}

/** Specifies the log level type for processor engine logs. */
export enum ProcessorEngineLogLevelType {
    All = 0,
    Debug = 1,
    Information = 2,
    Warning = 3,
    Error = 4,
}

export enum ProcessorStateEnum {
    NotRun = 0,
    Busy = 1,
    Finished = 2,
    Error = 3,
    NoData = 4,
}

export enum RelatedDocumentTypes {
    TextDocument = 0,
    Media = 1,
}

export enum UrlActionType {
    ACTIVATEUSER = 0,
    RESETPASSWORD = 1,
    REGISTERUSER = 2,
    ACTIVATEENVIRONMENT = 3,
    ACTIVATEENVIRONMENTANDUSER = 4,
    LOGIN = 5,
    DISAGREEINVOICE = 6,
    AGREEINVOICE = 7,
    REDIRECT = 8,
    AGREEASSIGNMENT = 9,
    DISAGREEASSIGNMENT = 10,
}

export enum VDBPermissionLevel {
    None = 0,
    Read = 1,
    Write = 2,
    Full = 3,
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
